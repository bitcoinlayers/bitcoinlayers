#!/usr/bin/env python3
"""
Governance Deep Analyzer

A specialized script for deep analysis of governance contracts discovered 
from the main token analyzer. Focuses on:
- Bridge validator sets and signers
- Gnosis Safe multisigs 
- Timelock contracts
- Access control systems
"""

import json
import os
import requests
from web3 import Web3
from typing import Optional, Dict, Any
from dotenv import load_dotenv

# Load environment variables from .env file (two directories up from this script)
load_dotenv(os.path.join(os.path.dirname(__file__), "..", "..", ".env"))

# Configuration - Load sensitive values from environment variables
ALCHEMY_RPC_URL = os.getenv("ALCHEMY_RPC_URL")
ETHERSCAN_API_KEY = os.getenv("ETHERSCAN_API_KEY")

# Validate required environment variables
if not ALCHEMY_RPC_URL:
    raise ValueError("ALCHEMY_RPC_URL environment variable is required")
if not ETHERSCAN_API_KEY:
    raise ValueError("ETHERSCAN_API_KEY environment variable is required")

# TARGET CONTRACT - Update this with the contract you want to analyze
TARGET_CONTRACT = "0xdad58DfA5c1a7a34419AFdBE1f0d610efeea95E4"  # Consortium contract example

# EIP-1967 storage slots
EIP1967_IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
EIP1967_ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103"

class GovernanceAnalyzer:
    def __init__(self, rpc_url: str, etherscan_api_key: str):
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))
        self.etherscan_api_key = etherscan_api_key
        
        if not self.w3.is_connected():
            raise ConnectionError("Failed to connect to Ethereum network")
    
    def get_contract_abi(self, address: str) -> Optional[Dict[str, Any]]:
        """
        Fetch contract ABI from Etherscan API
        """
        url = "https://api.etherscan.io/api"
        params = {
            "module": "contract",
            "action": "getsourcecode",
            "address": address,
            "apikey": self.etherscan_api_key
        }
        
        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()
            
            if data["status"] != "1":
                print(f"Etherscan API error: {data.get('message', 'Unknown error')}")
                return None
            
            result = data["result"][0]
            abi_string = result.get("ABI")
            
            if abi_string == "Contract source code not verified":
                return {"verified": False, "abi": None}
            
            try:
                abi = json.loads(abi_string)
                return {"verified": True, "abi": abi}
            except json.JSONDecodeError:
                print("Failed to parse ABI JSON")
                return {"verified": False, "abi": None}
                
        except requests.RequestException as e:
            print(f"Failed to fetch ABI from Etherscan: {e}")
            return None
    
    def _get_address_type(self, address: str) -> str:
        """
        Determine if address is a contract or EOA
        """
        try:
            code = self.w3.eth.get_code(address)
            return "Contract" if code != b'' else "EOA"
        except:
            return "Unknown"
    
    def _check_gnosis_safe(self, address: str) -> Optional[Dict[str, Any]]:
        """
        Check if an address is a Gnosis Safe and get threshold/owners
        """
        try:
            gnosis_safe_abi = [
                {
                    "constant": True,
                    "inputs": [],
                    "name": "getThreshold",
                    "outputs": [{"name": "", "type": "uint256"}],
                    "type": "function"
                },
                {
                    "constant": True,
                    "inputs": [],
                    "name": "getOwners",
                    "outputs": [{"name": "", "type": "address[]"}],
                    "type": "function"
                }
            ]
            
            contract = self.w3.eth.contract(address=Web3.to_checksum_address(address), abi=gnosis_safe_abi)
            
            threshold = contract.functions.getThreshold().call()
            owners = contract.functions.getOwners().call()
            
            return {
                "threshold": threshold,
                "total_owners": len(owners),
                "owners": [Web3.to_checksum_address(owner) for owner in owners],
                "multisig_type": f"{threshold}/{len(owners)} Gnosis Safe"
            }
            
        except Exception:
            return None
    
    def check_proxy_pattern(self, address: str) -> Dict[str, Any]:
        """
        Check if the contract follows EIP-1967 proxy pattern
        """
        proxy_info = {
            "is_proxy": False,
            "implementation_address": None,
            "admin_address": None
        }
        
        try:
            # Check implementation slot (EIP-1967)
            impl_slot_data = self.w3.eth.get_storage_at(address, EIP1967_IMPLEMENTATION_SLOT)
            
            if impl_slot_data != b'\x00' * 32:
                # Extract address from storage (last 20 bytes)
                impl_bytes = impl_slot_data[-20:]
                impl_hex = impl_bytes.hex()
                
                # Handle case where hex() might include 0x prefix
                if impl_hex.startswith('0x'):
                    impl_address = impl_hex
                else:
                    impl_address = '0x' + impl_hex
                
                if impl_address != '0x' + '00' * 20:  # Check if not zero address
                    proxy_info["is_proxy"] = True
                    # Ensure proper hex format before checksum conversion
                    if len(impl_address) == 42:  # 0x + 40 hex chars
                        proxy_info["implementation_address"] = Web3.to_checksum_address(impl_address)
            
            # Check admin slot (EIP-1967)
            admin_slot_data = self.w3.eth.get_storage_at(address, EIP1967_ADMIN_SLOT)
            
            if admin_slot_data != b'\x00' * 32:
                admin_bytes = admin_slot_data[-20:]
                admin_address = '0x' + admin_bytes.hex()
                if admin_address != '0x' + '00' * 20:
                    # Ensure proper hex format before checksum conversion
                    if len(admin_address) == 42:  # 0x + 40 hex chars
                        proxy_info["admin_address"] = Web3.to_checksum_address(admin_address)
        
        except Exception as e:
            print(f"Error checking proxy pattern: {e}")
        
        return proxy_info
    
    def detect_contract_type(self, address: str, abi: list) -> str:
        """
        Detect what type of governance/role contract this is
        """
        function_names = [item.get('name', '').lower() for item in abi if item.get('type') == 'function']
        
        # Bridge validator set detection
        if any(name in function_names for name in ['getvalidatorset', 'validators', 'signers']):
            return "bridge_validator_set"
        
        # Timelock detection
        if any(name in function_names for name in ['executetransaction', 'queuetransaction', 'getmindelay']):
            return "timelock"
        
        # Gnosis Safe detection
        if any(name in function_names for name in ['getthreshold', 'getowners']):
            return "gnosis_safe"
        
        # Access control detection
        if any(name in function_names for name in ['hasrole', 'grantrole', 'revokerole']):
            return "access_control"
        
        return "generic"
    
    def analyze_all_functions(self, address: str, abi: list) -> Dict[str, Any]:
        """
        Call all view functions and analyze their results
        """
        print("\nüîç COMPREHENSIVE FUNCTION ANALYSIS")
        print("=" * 70)
        
        analysis = {
            "function_results": {}, 
            "addresses": set(), 
            "interesting_data": {},
            "validator_sets": {},
            "current_epoch": None
        }
        contract = self.w3.eth.contract(address=Web3.to_checksum_address(address), abi=abi)
        
        # Find all view functions with no parameters
        view_functions = []
        for item in abi:
            if (item.get('type') == 'function' and 
                item.get('stateMutability') in ['view', 'pure'] and
                len(item.get('inputs', [])) == 0):
                view_functions.append(item.get('name'))
        
        print(f"üìã Found {len(view_functions)} view functions with no parameters:")
        for func in view_functions:
            print(f"   ‚Ä¢ {func}")
        
        print(f"\nüéØ CALLING ALL FUNCTIONS:")
        print("-" * 50)
        
        # Call each function and analyze results
        for func_name in view_functions:
            try:
                print(f"\nüîç Calling {func_name}()...")
                result = getattr(contract.functions, func_name)().call()
                
                # Store raw result
                analysis["function_results"][func_name] = result
                
                # Analyze and display result
                self._analyze_function_result(func_name, result, analysis)
                
            except Exception as e:
                print(f"   ‚ùå Error: {str(e)[:80]}...")
                continue
        
        # Try calling functions with parameters using discovered data
        self._try_parameterized_functions(contract, abi, analysis)
        
        # Summary of extracted addresses
        if analysis["addresses"]:
            print(f"\nüìä EXTRACTED ADDRESSES SUMMARY:")
            print("-" * 50)
            unique_addresses = list(analysis["addresses"])
            
            for i, addr in enumerate(unique_addresses, 1):
                addr_type = self._get_address_type(addr)
                print(f"{i:2d}. {addr} ({addr_type})")
                
                if addr_type == "Contract":
                    # Quick check if it's a Gnosis Safe
                    safe_info = self._check_gnosis_safe(addr)
                    if safe_info:
                        print(f"    üîê {safe_info['multisig_type']}")
        
        return analysis
    
    def _analyze_function_result(self, func_name: str, result, analysis: Dict[str, Any]):
        """
        Analyze the result of a function call and extract useful information
        """
        print(f"   üìÑ Result type: {type(result).__name__}")
        
        if isinstance(result, str):
            print(f"   üìù String: {result}")
            
            # Check if it's an address
            if len(result) == 42 and result.startswith('0x'):
                print(f"   üéØ Contains address: {result}")
                analysis["addresses"].add(result)
        
        elif isinstance(result, int):
            print(f"   üî¢ Number: {result}")
            analysis["interesting_data"][func_name] = result
            
            # If this looks like an epoch, save it
            if 'epoch' in func_name.lower():
                analysis["current_epoch"] = result
                print(f"   ‚≠ê Current epoch detected: {result}")
                
        elif isinstance(result, (list, tuple)):
            print(f"   üìã Array/Tuple with {len(result)} items:")
            
            # Try to extract addresses from any array/tuple result
            extracted_addresses = self._parse_complex_validator_result(result)
            if extracted_addresses:
                print(f"   üéØ EXTRACTED {len(extracted_addresses)} ADDRESSES!")
                analysis["validator_sets"][func_name] = extracted_addresses
                
                # Show first few addresses as preview
                for i, addr in enumerate(extracted_addresses[:5]):
                    print(f"      {i+1}. {addr}")
                if len(extracted_addresses) > 5:
                    print(f"      ... and {len(extracted_addresses) - 5} more addresses")
            else:
                # Show general structure for debugging
                for i, item in enumerate(result[:3]):
                    if isinstance(item, (list, tuple)):
                        print(f"      {i+1}. Array with {len(item)} items")
                    else:
                        print(f"      {i+1}. {str(item)[:50]}{'...' if len(str(item)) > 50 else ''}")
                if len(result) > 3:
                    print(f"      ... and {len(result) - 3} more items")
        
        elif isinstance(result, bool):
            print(f"   ‚úÖ Boolean: {result}")
        
        else:
            print(f"   üì¶ Complex: {str(result)[:100]}{'...' if len(str(result)) > 100 else ''}")
         
        print()

    def _try_parameterized_functions(self, contract, abi: list, analysis: Dict[str, Any]):
        """
        Try calling functions with parameters using discovered data
        """
        print(f"\nüéØ TRYING PARAMETERIZED FUNCTIONS:")
        print("-" * 50)
        
        # Find functions that take parameters
        param_functions = []
        for item in abi:
            if (item.get('type') == 'function' and 
                item.get('stateMutability') in ['view', 'pure'] and
                len(item.get('inputs', [])) > 0):
                param_functions.append({
                    'name': item.get('name'),
                    'inputs': item.get('inputs', [])
                })
        
        print(f"üìã Found {len(param_functions)} functions with parameters:")
        for func in param_functions:
            inputs_desc = ', '.join([f"{inp.get('type')} {inp.get('name', '')}" for inp in func['inputs']])
            print(f"   ‚Ä¢ {func['name']}({inputs_desc})")
        
        # Get discovered numeric values
        numeric_values = []
        for key, value in analysis["interesting_data"].items():
            if isinstance(value, int):
                numeric_values.append(value)
        
        # Add some common values to try (generic, not contract-specific)
        common_values = [0, 1, 2]
        if analysis.get("current_epoch") is not None:
            common_values.append(analysis["current_epoch"])
        numeric_values.extend(common_values)
        numeric_values = list(set(numeric_values))  # Remove duplicates
        
        print(f"\nüî¢ Will try these numeric values: {numeric_values}")
        
        # Try calling functions with single uint256 parameter
        for func_info in param_functions:
            func_name = func_info['name']
            inputs = func_info['inputs']
            
            # Only try functions with single uint256 parameter for now
            if (len(inputs) == 1 and 
                inputs[0].get('type') in ['uint256', 'uint', 'int256', 'int']):
                
                print(f"\nüîç Trying {func_name} with different values...")
                
                for value in numeric_values:
                    try:
                        result = getattr(contract.functions, func_name)(value).call()
                        print(f"   ‚úÖ {func_name}({value}):")
                        
                        # Analyze this result too
                        self._analyze_function_result(f"{func_name}({value})", result, analysis)
                        
                        # If we get a good result (non-empty), continue testing other values
                        if isinstance(result, (list, tuple)) and len(result) > 0:
                            # This looks promising - check if it has addresses
                            extracted_addresses = self._parse_complex_validator_result(result)
                            if extracted_addresses:
                                print(f"   üéØ Found {len(extracted_addresses)} addresses in result!")
                                break  # Stop trying more values for this function
                        
                    except Exception as e:
                        if "execution reverted" not in str(e).lower():
                            print(f"   ‚ö†Ô∏è  {func_name}({value}): {str(e)[:50]}...")
                        continue
    
    def _parse_complex_validator_result(self, result) -> list:
        """
        Enhanced parser for complex validator set results
        """
        validators = []
        
        def extract_addresses_recursive(data):
            """Recursively extract addresses from nested structures"""
            if isinstance(data, str):
                if len(data) == 42 and data.startswith('0x'):
                    # Valid address format
                    if data != '0x0000000000000000000000000000000000000000':
                        try:
                            validators.append(Web3.to_checksum_address(data))
                        except:
                            pass
            elif isinstance(data, (list, tuple)):
                for item in data:
                    extract_addresses_recursive(item)
        
        extract_addresses_recursive(result)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_validators = []
        for validator in validators:
            if validator not in seen:
                seen.add(validator)
                unique_validators.append(validator)
        
        return unique_validators

    def display_analysis_summary(self, analysis: Dict[str, Any], address: str):
        """
        Display a summary of all discovered data from the analysis
        """
        print("\n" + "=" * 70)
        print("üìä ANALYSIS SUMMARY")
        print("=" * 70)
        
        # Show discovered addresses
        if analysis["addresses"]:
            print(f"\nüéØ DISCOVERED ADDRESSES ({len(analysis['addresses'])} total):")
            print("-" * 50)
            for i, addr in enumerate(sorted(analysis["addresses"]), 1):
                addr_type = self._get_address_type(addr)
                print(f" {i:2d}. {addr} ({addr_type})")
        
        # Show interesting numeric data
        if analysis["interesting_data"]:
            print(f"\nüî¢ INTERESTING DATA:")
            print("-" * 50)
            for func_name, value in analysis["interesting_data"].items():
                print(f"   ‚Ä¢ {func_name}: {value}")
        
        # Show validator sets / address arrays
        if analysis["validator_sets"]:
            print(f"\nüìã ADDRESS ARRAYS FOUND ({len(analysis['validator_sets'])} functions):")
            print("-" * 50)
            for func_name, addresses in analysis["validator_sets"].items():
                print(f"\n   üìç {func_name}() returned {len(addresses)} addresses:")
                for i, addr in enumerate(addresses[:10], 1):  # Show first 10
                    addr_type = self._get_address_type(addr)
                    print(f"      {i:2d}. {addr} ({addr_type})")
                if len(addresses) > 10:
                    print(f"      ... and {len(addresses) - 10} more addresses")
        
        print(f"\nüîç Full contract details: https://etherscan.io/address/{address}")
        print("=" * 70)
    
    def analyze_timelock(self, address: str, abi: list) -> Dict[str, Any]:
        """
        Analyze timelock contracts
        """
        print("\n‚è∞ TIMELOCK ANALYSIS")
        print("=" * 70)
        
        analysis = {"delay": None, "admin": None, "pending_count": 0}
        contract = self.w3.eth.contract(address=Web3.to_checksum_address(address), abi=abi)
        
        # Get timelock delay
        try:
            if hasattr(contract.functions, 'getMinDelay'):
                delay = contract.functions.getMinDelay().call()
                analysis["delay"] = delay
                print(f"‚è±Ô∏è  Minimum delay: {delay} seconds ({delay//3600:.1f} hours)")
            elif hasattr(contract.functions, 'delay'):
                delay = contract.functions.delay().call()
                analysis["delay"] = delay
                print(f"‚è±Ô∏è  Delay: {delay} seconds ({delay//3600:.1f} hours)")
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not get delay: {str(e)[:50]}")
        
        # Get admin/roles
        try:
            if hasattr(contract.functions, 'admin'):
                admin = contract.functions.admin().call()
                analysis["admin"] = admin
                print(f"üë§ Admin: {admin}")
        except Exception:
            pass
        
        return analysis
    
    def analyze_access_control(self, address: str, abi: list) -> Dict[str, Any]:
        """
        Analyze access control contracts
        """
        print("\nüîê ACCESS CONTROL ANALYSIS")
        print("=" * 70)
        
        analysis = {"roles": {}, "role_functions": []}
        
        # Find role-related functions
        role_functions = []
        for item in abi:
            if (item.get('type') == 'function' and 
                any(keyword in item.get('name', '').lower() for keyword in ['role', 'admin'])):
                role_functions.append(item.get('name'))
        
        analysis["role_functions"] = role_functions
        print(f"üìã Found {len(role_functions)} role-related functions:")
        for func in role_functions:
            print(f"   ‚Ä¢ {func}")
        
        return analysis
    
    def analyze_gnosis_safe(self, address: str) -> Dict[str, Any]:
        """
        Deep analysis of Gnosis Safe
        """
        print("\nüîê GNOSIS SAFE DEEP ANALYSIS")
        print("=" * 70)
        
        safe_info = self._check_gnosis_safe(address)
        if not safe_info:
            print("‚ùå Not a Gnosis Safe or incompatible version")
            return {}
        
        print(f"‚úÖ Confirmed Gnosis Safe: {safe_info['multisig_type']}")
        print(f"üë• Total owners: {safe_info['total_owners']}")
        print(f"üî¢ Threshold: {safe_info['threshold']}")
        
        print(f"\nüìã OWNER ANALYSIS:")
        for i, owner in enumerate(safe_info['owners'], 1):
            owner_type = self._get_address_type(owner)
            print(f"{i:2d}. {owner} ({owner_type})")
            
            if owner_type == "Contract":
                # Check if owner is also a Gnosis Safe (nested multisig)
                nested_safe = self._check_gnosis_safe(owner)
                if nested_safe:
                    print(f"    üîê Nested {nested_safe['multisig_type']}")
        
        return safe_info
    
    def run_analysis(self, address: str):
        """
        Main analysis function
        """
        print(f"üî¨ GOVERNANCE DEEP ANALYZER")
        print("=" * 70)
        print(f"üéØ Target: {address}")
        print("=" * 70)
        
        # Get contract ABI
        print("1. Fetching contract ABI...")
        abi_data = self.get_contract_abi(address)
        
        if not abi_data:
            print("‚ùå Failed to fetch contract data")
            return
        
        if not abi_data["verified"]:
            print("‚ùå Contract is not verified on Etherscan")
            return
        
        print("‚úÖ Contract is verified")
        
        # Check if it's a proxy and get the right ABI
        print("\n2. Checking for proxy pattern...")
        proxy_info = self.check_proxy_pattern(address)
        abi_to_use = abi_data["abi"]
        
        if proxy_info["is_proxy"]:
            print(f"üîó Contract is an upgradeable proxy")
            print(f"üìç Implementation: {proxy_info['implementation_address']}")
            
            # Get implementation ABI
            impl_abi_data = self.get_contract_abi(proxy_info["implementation_address"])
            if impl_abi_data and impl_abi_data["verified"]:
                print("‚úÖ Implementation contract is verified - using implementation ABI")
                abi_to_use = impl_abi_data["abi"]
            else:
                print("‚ö†Ô∏è  Implementation contract not verified - using proxy ABI")
        else:
            print("üìÑ Contract is not a proxy")
        
        # Detect contract type
        print(f"\n3. Detecting contract type...")
        contract_type = self.detect_contract_type(address, abi_to_use)
        print(f"üîç Detected type: {contract_type.upper()}")
        
        # Perform specialized analysis
        print(f"\n4. Performing specialized analysis...")
        
        # For all contract types, run comprehensive function analysis
        analysis_results = self.analyze_all_functions(address, abi_to_use)
        
        # Display summary of discovered data
        self.display_analysis_summary(analysis_results, address)
        
        # If it's a Gnosis Safe, also run specialized safe analysis
        if contract_type == "gnosis_safe":
            print("\n" + "="*70)
            self.analyze_gnosis_safe(address)
        
        print(f"\nüîç View on Etherscan: https://etherscan.io/address/{address}")
        print("=" * 70)
        
        return analysis


def main():
    """
    Main function
    """
    print("üî¨ Ethereum Governance Deep Analyzer")
    print("=" * 70)
    
    try:
        # Initialize analyzer
        analyzer = GovernanceAnalyzer(ALCHEMY_RPC_URL, ETHERSCAN_API_KEY)
        
        # Run analysis
        analyzer.run_analysis(TARGET_CONTRACT)
        
    except ConnectionError as e:
        print(f"‚ùå Connection Error: {e}")
        print("Please check your Alchemy RPC URL and internet connection.")
    except Exception as e:
        print(f"‚ùå Unexpected Error: {e}")


if __name__ == "__main__":
    main() 