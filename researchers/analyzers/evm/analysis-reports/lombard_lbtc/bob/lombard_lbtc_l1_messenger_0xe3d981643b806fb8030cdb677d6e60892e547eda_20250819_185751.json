{
  "contract_address": "0xE3d981643b806FB8030CDB677D6E60892E547EdA",
  "network": "ethereum",
  "analysis_timestamp": "2025-08-19T18:57:40.511060",
  "contract_info": {
    "verified": true,
    "abi": [
      {
        "inputs": [
          {
            "internalType": "contract AddressManager",
            "name": "_addressManager",
            "type": "address"
          },
          {
            "internalType": "string",
            "name": "_implementationName",
            "type": "string"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "stateMutability": "payable",
        "type": "fallback"
      }
    ],
    "contract_name": "ResolvedDelegateProxy",
    "compiler_version": "v0.8.15+commit.e14f2714",
    "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/legacy/ResolvedDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { AddressManager } from \\\"./AddressManager.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title ResolvedDelegateProxy\\n * @notice ResolvedDelegateProxy is a legacy proxy contract that makes use of the AddressManager to\\n *         resolve the implementation address. We're maintaining this contract for backwards\\n *         compatibility so we can manage all legacy proxies where necessary.\\n */\\ncontract ResolvedDelegateProxy {\\n    /**\\n     * @notice Mapping used to store the implementation name that corresponds to this contract. A\\n     *         mapping was originally used as a way to bypass the same issue normally solved by\\n     *         storing the implementation address in a specific storage slot that does not conflict\\n     *         with any other storage slot. Generally NOT a safe solution but works as long as the\\n     *         implementation does not also keep a mapping in the first storage slot.\\n     */\\n    mapping(address => string) private implementationName;\\n\\n    /**\\n     * @notice Mapping used to store the address of the AddressManager contract where the\\n     *         implementation address will be resolved from. Same concept here as with the above\\n     *         mapping. Also generally unsafe but fine if the implementation doesn't keep a mapping\\n     *         in the second storage slot.\\n     */\\n    mapping(address => AddressManager) private addressManager;\\n\\n    /**\\n     * @param _addressManager  Address of the AddressManager.\\n     * @param _implementationName implementationName of the contract to proxy to.\\n     */\\n    constructor(AddressManager _addressManager, string memory _implementationName) {\\n        addressManager[address(this)] = _addressManager;\\n        implementationName[address(this)] = _implementationName;\\n    }\\n\\n    /**\\n     * @notice Fallback, performs a delegatecall to the resolved implementation address.\\n     */\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address target = addressManager[address(this)].getAddress(\\n            (implementationName[address(this)])\\n        );\\n\\n        require(target != address(0), \\\"ResolvedDelegateProxy: target address must be initialized\\\");\\n\\n        // slither-disable-next-line controlled-delegatecall\\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\\n\\n        if (success == true) {\\n            assembly {\\n                return(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title AddressManager\\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n *         system to manage a registry of string names to addresses. We now use a more standard\\n *         proxy system instead, but this contract is still necessary for backwards compatibility\\n *         with several older contracts.\\n */\\ncontract AddressManager is Ownable {\\n    /**\\n     * @notice Mapping of the hashes of string names to addresses.\\n     */\\n    mapping(bytes32 => address) private addresses;\\n\\n    /**\\n     * @notice Emitted when an address is modified in the registry.\\n     *\\n     * @param name       String name being set in the registry.\\n     * @param newAddress Address set for the given name.\\n     * @param oldAddress Address that was previously set for the given name.\\n     */\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /**\\n     * @notice Changes the address associated with a particular name.\\n     *\\n     * @param _name    String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * @notice Retrieves the address associated with a given name.\\n     *\\n     * @param _name Name to retrieve an address for.\\n     *\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**\\n     * @notice Computes the hash of a name.\\n     *\\n     * @param _name Name to compute a hash for.\\n     *\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@cwia/=node_modules/clones-with-immutable-args/src/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"@rari-capital/=node_modules/@rari-capital/\",\r\n      \"@rari-capital/solmate/=node_modules/@rari-capital/solmate/\",\r\n      \"clones-with-immutable-args/=node_modules/clones-with-immutable-args/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "implementation_abi": {
      "verified": true,
      "abi": [
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "inputs": [],
          "name": "ProxyAdminOwnedBase_NotProxyAdmin",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ProxyAdminOwnedBase_NotProxyAdminOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ProxyAdminOwnedBase_NotResolvedDelegateProxy",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ProxyAdminOwnedBase_NotSharedProxyAdminOwner",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ProxyAdminOwnedBase_ProxyAdminNotFound",
          "type": "error"
        },
        {
          "inputs": [],
          "name": "ReinitializableBase_ZeroInitVersion",
          "type": "error"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "bytes32",
              "name": "msgHash",
              "type": "bytes32"
            }
          ],
          "name": "FailedRelayedMessage",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": false,
              "internalType": "uint8",
              "name": "version",
              "type": "uint8"
            }
          ],
          "name": "Initialized",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "bytes32",
              "name": "msgHash",
              "type": "bytes32"
            }
          ],
          "name": "RelayedMessage",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "messageNonce",
              "type": "uint256"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "gasLimit",
              "type": "uint256"
            }
          ],
          "name": "SentMessage",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "indexed": false,
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            }
          ],
          "name": "SentMessageExtension1",
          "type": "event"
        },
        {
          "inputs": [],
          "name": "ENCODING_OVERHEAD",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "FLOOR_CALLDATA_OVERHEAD",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MESSAGE_VERSION",
          "outputs": [
            {
              "internalType": "uint16",
              "name": "",
              "type": "uint16"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MIN_GAS_CALLDATA_OVERHEAD",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "OTHER_MESSENGER",
          "outputs": [
            {
              "internalType": "contract CrossDomainMessenger",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "PORTAL",
          "outputs": [
            {
              "internalType": "contract IOptimismPortal2",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "RELAY_CALL_OVERHEAD",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "RELAY_CONSTANT_OVERHEAD",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "RELAY_GAS_CHECK_BUFFER",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "RELAY_RESERVED_GAS",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "TX_BASE_GAS",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "_message",
              "type": "bytes"
            },
            {
              "internalType": "uint32",
              "name": "_minGasLimit",
              "type": "uint32"
            }
          ],
          "name": "baseGas",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "failedMessages",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "initVersion",
          "outputs": [
            {
              "internalType": "uint8",
              "name": "",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract ISystemConfig",
              "name": "_systemConfig",
              "type": "address"
            },
            {
              "internalType": "contract IOptimismPortal2",
              "name": "_portal",
              "type": "address"
            }
          ],
          "name": "initialize",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "messageNonce",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "otherMessenger",
          "outputs": [
            {
              "internalType": "contract CrossDomainMessenger",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "paused",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "portal",
          "outputs": [
            {
              "internalType": "contract IOptimismPortal2",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "proxyAdmin",
          "outputs": [
            {
              "internalType": "contract IProxyAdmin",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "proxyAdminOwner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_nonce",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "_sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "_target",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_minGasLimit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "_message",
              "type": "bytes"
            }
          ],
          "name": "relayMessage",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_target",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "_message",
              "type": "bytes"
            },
            {
              "internalType": "uint32",
              "name": "_minGasLimit",
              "type": "uint32"
            }
          ],
          "name": "sendMessage",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32"
            }
          ],
          "name": "successfulMessages",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "superchainConfig",
          "outputs": [
            {
              "internalType": "contract ISuperchainConfig",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "systemConfig",
          "outputs": [
            {
              "internalType": "contract ISystemConfig",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract ISystemConfig",
              "name": "_systemConfig",
              "type": "address"
            }
          ],
          "name": "upgrade",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "version",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "xDomainMessageSender",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ],
      "contract_name": "L1CrossDomainMessenger",
      "compiler_version": "v0.8.15+commit.e14f2714",
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@lib-keccak/LibKeccak.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title LibKeccak\\n/// @notice An EVM implementation of the Keccak-f[1600] permutation.\\n/// @author clabby <https://github.com/clabby>\\n/// @custom:attribution geohot <https://github.com/geohot>\\nlibrary LibKeccak {\\n    /// @notice The block size of the Keccak-f[1600] permutation, 1088 bits (136 bytes).\\n    uint256 internal constant BLOCK_SIZE_BYTES = 136;\\n\\n    /// @notice The round constants for the keccak256 hash function. Packed in memory for efficient reading during the\\n    ///         permutation.\\n    bytes internal constant ROUND_CONSTANTS = abi.encode(\\n        0x00000000000000010000000000008082800000000000808a8000000080008000, // r1,r2,r3,r4\\n        0x000000000000808b000000008000000180000000800080818000000000008009, // r5,r6,r7,r8\\n        0x000000000000008a00000000000000880000000080008009000000008000000a, // r9,r10,r11,r12\\n        0x000000008000808b800000000000008b80000000000080898000000000008003, // r13,r14,r15,r16\\n        0x80000000000080028000000000000080000000000000800a800000008000000a, // r17,r18,r19,r20\\n        0x8000000080008081800000000000808000000000800000018000000080008008 // r21,r22,r23,r24\\n    );\\n\\n    /// @notice A mask for 64-bit values.\\n    uint64 private constant U64_MASK = 0xFFFFFFFFFFFFFFFF;\\n\\n    /// @notice The 5x5 state matrix for the keccak-f[1600] permutation.\\n    struct StateMatrix {\\n        uint64[25] state;\\n    }\\n\\n    /// @notice Performs the Keccak-f[1600] permutation on the given 5x5 state matrix.\\n    function permutation(StateMatrix memory _stateMatrix) internal pure {\\n        // Pull the round constants into memory to avoid reallocation in the unrolled permutation loop.\\n        bytes memory roundConstants = ROUND_CONSTANTS;\\n\\n        assembly {\\n            // Add 32 to the state matrix pointer to skip the data location field.\\n            let stateMatrixPtr := add(_stateMatrix, 0x20)\\n            let rcPtr := add(roundConstants, 0x20)\\n\\n            // set a state element in the passed `StateMatrix` struct memory ptr.\\n            function setStateElem(ptr, idx, data) {\\n                mstore(add(ptr, shl(0x05, idx)), and(data, U64_MASK))\\n            }\\n\\n            // fetch a state element from the passed `StateMatrix` struct memory ptr.\\n            function stateElem(ptr, idx) -> elem {\\n                elem := mload(add(ptr, shl(0x05, idx)))\\n            }\\n\\n            // 64 bit logical shift\\n            function shl64(a, b) -> val {\\n                val := and(shl(a, b), U64_MASK)\\n            }\\n\\n            // Performs an indivudual rho + pi computation, to be used in the full `thetaRhoPi` chain.\\n            function rhoPi(ptr, destIdx, srcIdx, fact, dt) {\\n                let xs1 := xor(stateElem(ptr, srcIdx), dt)\\n                let res := xor(shl(fact, xs1), shr(sub(64, fact), xs1))\\n                setStateElem(ptr, destIdx, res)\\n            }\\n\\n            // xor a column in the state matrix\\n            function xorColumn(ptr, col) -> val {\\n                val :=\\n                    xor(\\n                        xor(xor(stateElem(ptr, col), stateElem(ptr, add(col, 5))), stateElem(ptr, add(col, 10))),\\n                        xor(stateElem(ptr, add(col, 15)), stateElem(ptr, add(col, 20)))\\n                    )\\n            }\\n\\n            // Performs the `theta`, `rho`, and `pi` steps of the Keccak-f[1600] permutation on\\n            // the passed `StateMatrix` struct memory ptr.\\n            function thetaRhoPi(ptr) {\\n                // Theta\\n                let C0 := xorColumn(ptr, 0)\\n                let C1 := xorColumn(ptr, 1)\\n                let C2 := xorColumn(ptr, 2)\\n                let C3 := xorColumn(ptr, 3)\\n                let C4 := xorColumn(ptr, 4)\\n                let D0 := xor(xor(shl64(1, C1), shr(63, C1)), C4)\\n                let D1 := xor(xor(shl64(1, C2), shr(63, C2)), C0)\\n                let D2 := xor(xor(shl64(1, C3), shr(63, C3)), C1)\\n                let D3 := xor(xor(shl64(1, C4), shr(63, C4)), C2)\\n                let D4 := xor(xor(shl64(1, C0), shr(63, C0)), C3)\\n\\n                let xs1 := xor(stateElem(ptr, 1), D1)\\n                let A1 := xor(shl(1, xs1), shr(63, xs1))\\n\\n                let _ptr := ptr\\n                setStateElem(_ptr, 0, xor(stateElem(_ptr, 0), D0))\\n                rhoPi(_ptr, 1, 6, 44, D1)\\n                rhoPi(_ptr, 6, 9, 20, D4)\\n                rhoPi(_ptr, 9, 22, 61, D2)\\n                rhoPi(_ptr, 22, 14, 39, D4)\\n                rhoPi(_ptr, 14, 20, 18, D0)\\n                rhoPi(_ptr, 20, 2, 62, D2)\\n                rhoPi(_ptr, 2, 12, 43, D2)\\n                rhoPi(_ptr, 12, 13, 25, D3)\\n                rhoPi(_ptr, 13, 19, 8, D4)\\n                rhoPi(_ptr, 19, 23, 56, D3)\\n                rhoPi(_ptr, 23, 15, 41, D0)\\n                rhoPi(_ptr, 15, 4, 27, D4)\\n                rhoPi(_ptr, 4, 24, 14, D4)\\n                rhoPi(_ptr, 24, 21, 2, D1)\\n                rhoPi(_ptr, 21, 8, 55, D3)\\n                rhoPi(_ptr, 8, 16, 45, D1)\\n                rhoPi(_ptr, 16, 5, 36, D0)\\n                rhoPi(_ptr, 5, 3, 28, D3)\\n                rhoPi(_ptr, 3, 18, 21, D3)\\n                rhoPi(_ptr, 18, 17, 15, D2)\\n                rhoPi(_ptr, 17, 11, 10, D1)\\n                rhoPi(_ptr, 11, 7, 6, D2)\\n                rhoPi(_ptr, 7, 10, 3, D0)\\n                setStateElem(_ptr, 10, A1)\\n            }\\n\\n            // Inner `chi` function, unrolled in `chi` for performance.\\n            function innerChi(ptr, start) {\\n                let A0 := stateElem(ptr, start)\\n                let A1 := stateElem(ptr, add(start, 1))\\n                let A2 := stateElem(ptr, add(start, 2))\\n                let A3 := stateElem(ptr, add(start, 3))\\n                let A4 := stateElem(ptr, add(start, 4))\\n\\n                setStateElem(ptr, start, xor(A0, and(not(A1), A2)))\\n                setStateElem(ptr, add(start, 1), xor(A1, and(not(A2), A3)))\\n                setStateElem(ptr, add(start, 2), xor(A2, and(not(A3), A4)))\\n                setStateElem(ptr, add(start, 3), xor(A3, and(not(A4), A0)))\\n                setStateElem(ptr, add(start, 4), xor(A4, and(not(A0), A1)))\\n            }\\n\\n            // Performs the `chi` step of the Keccak-f[1600] permutation on the passed `StateMatrix` struct memory ptr\\n            function chi(ptr) {\\n                innerChi(ptr, 0)\\n                innerChi(ptr, 5)\\n                innerChi(ptr, 10)\\n                innerChi(ptr, 15)\\n                innerChi(ptr, 20)\\n            }\\n\\n            // Perform the full Keccak-f[1600] permutation on a `StateMatrix` struct memory ptr for a given round.\\n            function permute(ptr, roundsPtr, round) {\\n                // Theta, Rho, Pi, Chi\\n                thetaRhoPi(ptr)\\n                chi(ptr)\\n                // Iota\\n                let roundConst := shr(192, mload(add(roundsPtr, shl(0x03, round))))\\n                setStateElem(ptr, 0, xor(stateElem(ptr, 0), roundConst))\\n            }\\n\\n            // Unroll the permutation loop.\\n            permute(stateMatrixPtr, rcPtr, 0)\\n            permute(stateMatrixPtr, rcPtr, 1)\\n            permute(stateMatrixPtr, rcPtr, 2)\\n            permute(stateMatrixPtr, rcPtr, 3)\\n            permute(stateMatrixPtr, rcPtr, 4)\\n            permute(stateMatrixPtr, rcPtr, 5)\\n            permute(stateMatrixPtr, rcPtr, 6)\\n            permute(stateMatrixPtr, rcPtr, 7)\\n            permute(stateMatrixPtr, rcPtr, 8)\\n            permute(stateMatrixPtr, rcPtr, 9)\\n            permute(stateMatrixPtr, rcPtr, 10)\\n            permute(stateMatrixPtr, rcPtr, 11)\\n            permute(stateMatrixPtr, rcPtr, 12)\\n            permute(stateMatrixPtr, rcPtr, 13)\\n            permute(stateMatrixPtr, rcPtr, 14)\\n            permute(stateMatrixPtr, rcPtr, 15)\\n            permute(stateMatrixPtr, rcPtr, 16)\\n            permute(stateMatrixPtr, rcPtr, 17)\\n            permute(stateMatrixPtr, rcPtr, 18)\\n            permute(stateMatrixPtr, rcPtr, 19)\\n            permute(stateMatrixPtr, rcPtr, 20)\\n            permute(stateMatrixPtr, rcPtr, 21)\\n            permute(stateMatrixPtr, rcPtr, 22)\\n            permute(stateMatrixPtr, rcPtr, 23)\\n        }\\n    }\\n\\n    /// @notice Absorb a fixed-sized block into the sponge.\\n    function absorb(StateMatrix memory _stateMatrix, bytes memory _input) internal pure {\\n        assembly {\\n            // The input must be 1088 bits long.\\n            if iszero(eq(mload(_input), BLOCK_SIZE_BYTES)) { revert(0, 0) }\\n\\n            let dataPtr := add(_input, 0x20)\\n            let statePtr := add(_stateMatrix, 0x20)\\n\\n            // set a state element in the passed `StateMatrix` struct memory ptr.\\n            function setStateElem(ptr, idx, data) {\\n                mstore(add(ptr, shl(0x05, idx)), and(data, U64_MASK))\\n            }\\n\\n            // fetch a state element from the passed `StateMatrix` struct memory ptr.\\n            function stateElem(ptr, idx) -> elem {\\n                elem := mload(add(ptr, shl(0x05, idx)))\\n            }\\n\\n            // Inner sha3 absorb XOR function\\n            function absorbInner(stateMatrixPtr, inputPtr, idx) {\\n                let boWord := mload(add(inputPtr, shl(3, idx)))\\n\\n                let res :=\\n                    or(\\n                        or(\\n                            or(shl(56, byte(7, boWord)), shl(48, byte(6, boWord))),\\n                            or(shl(40, byte(5, boWord)), shl(32, byte(4, boWord)))\\n                        ),\\n                        or(\\n                            or(shl(24, byte(3, boWord)), shl(16, byte(2, boWord))),\\n                            or(shl(8, byte(1, boWord)), byte(0, boWord))\\n                        )\\n                    )\\n                setStateElem(stateMatrixPtr, idx, xor(stateElem(stateMatrixPtr, idx), res))\\n            }\\n\\n            // Unroll the input XOR loop.\\n            absorbInner(statePtr, dataPtr, 0)\\n            absorbInner(statePtr, dataPtr, 1)\\n            absorbInner(statePtr, dataPtr, 2)\\n            absorbInner(statePtr, dataPtr, 3)\\n            absorbInner(statePtr, dataPtr, 4)\\n            absorbInner(statePtr, dataPtr, 5)\\n            absorbInner(statePtr, dataPtr, 6)\\n            absorbInner(statePtr, dataPtr, 7)\\n            absorbInner(statePtr, dataPtr, 8)\\n            absorbInner(statePtr, dataPtr, 9)\\n            absorbInner(statePtr, dataPtr, 10)\\n            absorbInner(statePtr, dataPtr, 11)\\n            absorbInner(statePtr, dataPtr, 12)\\n            absorbInner(statePtr, dataPtr, 13)\\n            absorbInner(statePtr, dataPtr, 14)\\n            absorbInner(statePtr, dataPtr, 15)\\n            absorbInner(statePtr, dataPtr, 16)\\n        }\\n    }\\n\\n    /// @notice Squeezes the final keccak256 digest from the passed `StateMatrix`.\\n    function squeeze(StateMatrix memory _stateMatrix) internal pure returns (bytes32 hash_) {\\n        assembly {\\n            // 64 bit logical shift\\n            function shl64(a, b) -> val {\\n                val := and(shl(a, b), U64_MASK)\\n            }\\n\\n            // convert a big endian 64-bit value to a little endian 64-bit value.\\n            function toLE(beVal) -> leVal {\\n                beVal := or(and(shl64(8, beVal), 0xFF00FF00FF00FF00), and(shr(8, beVal), 0x00FF00FF00FF00FF))\\n                beVal := or(and(shl64(16, beVal), 0xFFFF0000FFFF0000), and(shr(16, beVal), 0x0000FFFF0000FFFF))\\n                leVal := or(shl64(32, beVal), shr(32, beVal))\\n            }\\n\\n            // fetch a state element from the passed `StateMatrix` struct memory ptr.\\n            function stateElem(ptr, idx) -> elem {\\n                elem := mload(add(ptr, shl(0x05, idx)))\\n            }\\n\\n            let stateMatrixPtr := add(_stateMatrix, 0x20)\\n            hash_ :=\\n                or(\\n                    or(shl(192, toLE(stateElem(stateMatrixPtr, 0))), shl(128, toLE(stateElem(stateMatrixPtr, 1)))),\\n                    or(shl(64, toLE(stateElem(stateMatrixPtr, 2))), toLE(stateElem(stateMatrixPtr, 3)))\\n                )\\n        }\\n    }\\n\\n    /// @notice Pads input data to an even multiple of the Keccak-f[1600] permutation block size, 1088 bits (136 bytes).\\n    function pad(bytes calldata _data) internal pure returns (bytes memory padded_) {\\n        assembly {\\n            padded_ := mload(0x40)\\n\\n            // Grab the original length of `_data`\\n            let len := _data.length\\n\\n            let dataPtr := add(padded_, 0x20)\\n            let endPtr := add(dataPtr, len)\\n\\n            // Copy the data into memory.\\n            calldatacopy(dataPtr, _data.offset, len)\\n\\n            let modBlockSize := mod(len, BLOCK_SIZE_BYTES)\\n            switch modBlockSize\\n            case false {\\n                // Clean the full padding block. It is possible that this memory is dirty, since solidity sometimes does\\n                // not update the free memory pointer when allocating memory, for example with external calls. To do\\n                // this, we read out-of-bounds from the calldata, which will always return 0 bytes.\\n                calldatacopy(endPtr, calldatasize(), BLOCK_SIZE_BYTES)\\n\\n                // If the input is a perfect multiple of the block size, then we add a full extra block of padding.\\n                mstore8(endPtr, 0x01)\\n                mstore8(sub(add(endPtr, BLOCK_SIZE_BYTES), 0x01), 0x80)\\n\\n                // Update the length of the data to include the padding.\\n                mstore(padded_, add(len, BLOCK_SIZE_BYTES))\\n            }\\n            default {\\n                // If the input is not a perfect multiple of the block size, then we add a partial block of padding.\\n                // This should entail a set bit after the input, followed by as many zero bits as necessary to fill\\n                // the block, followed by a single 1 bit in the lowest-order bit of the final block.\\n\\n                let remaining := sub(BLOCK_SIZE_BYTES, modBlockSize)\\n                let newLen := add(len, remaining)\\n                let paddedEndPtr := add(dataPtr, newLen)\\n\\n                // Clean the remainder to ensure that the intermediate data between the padding bits is 0. It is\\n                // possible that this memory is dirty, since solidity sometimes does not update the free memory pointer\\n                // when allocating memory, for example with external calls. To do this, we read out-of-bounds from the\\n                // calldata, which will always return 0 bytes.\\n                let partialRemainder := sub(paddedEndPtr, endPtr)\\n                calldatacopy(endPtr, calldatasize(), partialRemainder)\\n\\n                // Store the padding bits.\\n                mstore8(sub(paddedEndPtr, 0x01), 0x80)\\n                mstore8(endPtr, or(byte(0x00, mload(endPtr)), 0x01))\\n\\n                // Update the length of the data to include the padding. The length should be a multiple of the\\n                // block size after this.\\n                mstore(padded_, newLen)\\n            }\\n\\n            // Update the free memory pointer.\\n            mstore(0x40, add(padded_, and(add(mload(padded_), 0x3F), not(0x1F))))\\n        }\\n    }\\n\\n    /// @notice Pads input data to an even multiple of the Keccak-f[1600] permutation block size, 1088 bits (136 bytes).\\n    function padMemory(bytes memory _data) internal pure returns (bytes memory padded_) {\\n        assembly {\\n            padded_ := mload(0x40)\\n\\n            // Grab the original length of `_data`\\n            let len := mload(_data)\\n\\n            let dataPtr := add(padded_, 0x20)\\n            let endPtr := add(dataPtr, len)\\n\\n            // Copy the data.\\n            let originalDataPtr := add(_data, 0x20)\\n            for { let i := 0x00 } lt(i, len) { i := add(i, 0x20) } {\\n                mstore(add(dataPtr, i), mload(add(originalDataPtr, i)))\\n            }\\n\\n            let modBlockSize := mod(len, BLOCK_SIZE_BYTES)\\n            switch modBlockSize\\n            case false {\\n                // Clean the full padding block. It is possible that this memory is dirty, since solidity sometimes does\\n                // not update the free memory pointer when allocating memory, for example with external calls. To do\\n                // this, we read out-of-bounds from the calldata, which will always return 0 bytes.\\n                calldatacopy(endPtr, calldatasize(), BLOCK_SIZE_BYTES)\\n\\n                // If the input is a perfect multiple of the block size, then we add a full extra block of padding.\\n                mstore8(sub(add(endPtr, BLOCK_SIZE_BYTES), 0x01), 0x80)\\n                mstore8(endPtr, 0x01)\\n\\n                // Update the length of the data to include the padding.\\n                mstore(padded_, add(len, BLOCK_SIZE_BYTES))\\n            }\\n            default {\\n                // If the input is not a perfect multiple of the block size, then we add a partial block of padding.\\n                // This should entail a set bit after the input, followed by as many zero bits as necessary to fill\\n                // the block, followed by a single 1 bit in the lowest-order bit of the final block.\\n\\n                let remaining := sub(BLOCK_SIZE_BYTES, modBlockSize)\\n                let newLen := add(len, remaining)\\n                let paddedEndPtr := add(dataPtr, newLen)\\n\\n                // Clean the remainder to ensure that the intermediate data between the padding bits is 0. It is\\n                // possible that this memory is dirty, since solidity sometimes does not update the free memory pointer\\n                // when allocating memory, for example with external calls. To do this, we read out-of-bounds from the\\n                // calldata, which will always return 0 bytes.\\n                let partialRemainder := sub(paddedEndPtr, endPtr)\\n                calldatacopy(endPtr, calldatasize(), partialRemainder)\\n\\n                // Store the padding bits.\\n                mstore8(sub(paddedEndPtr, 0x01), 0x80)\\n                mstore8(endPtr, or(byte(0x00, mload(endPtr)), 0x01))\\n\\n                // Update the length of the data to include the padding. The length should be a multiple of the\\n                // block size after this.\\n                mstore(padded_, newLen)\\n            }\\n\\n            // Update the free memory pointer.\\n            mstore(0x40, add(padded_, and(add(mload(padded_), 0x3F), not(0x1F))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IETHLockbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ISemver } from \\\"interfaces/universal/ISemver.sol\\\";\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { IProxyAdminOwnedBase } from \\\"interfaces/L1/IProxyAdminOwnedBase.sol\\\";\\nimport { IOptimismPortal2 } from \\\"interfaces/L1/IOptimismPortal2.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IReinitializableBase } from \\\"interfaces/universal/IReinitializableBase.sol\\\";\\n\\ninterface IETHLockbox is IProxyAdminOwnedBase, ISemver, IReinitializableBase {\\n    error ETHLockbox_Unauthorized();\\n    error ETHLockbox_Paused();\\n    error ETHLockbox_InsufficientBalance();\\n    error ETHLockbox_NoWithdrawalTransactions();\\n    error ETHLockbox_DifferentSuperchainConfig();\\n\\n    event Initialized(uint8 version);\\n    event ETHLocked(IOptimismPortal2 indexed portal, uint256 amount);\\n    event ETHUnlocked(IOptimismPortal2 indexed portal, uint256 amount);\\n    event PortalAuthorized(IOptimismPortal2 indexed portal);\\n    event LockboxAuthorized(IETHLockbox indexed lockbox);\\n    event LiquidityMigrated(IETHLockbox indexed lockbox, uint256 amount);\\n    event LiquidityReceived(IETHLockbox indexed lockbox, uint256 amount);\\n\\n    function initialize(ISystemConfig _systemConfig, IOptimismPortal2[] calldata _portals) external;\\n    function systemConfig() external view returns (ISystemConfig);\\n    function paused() external view returns (bool);\\n    function authorizedPortals(IOptimismPortal2) external view returns (bool);\\n    function authorizedLockboxes(IETHLockbox) external view returns (bool);\\n    function receiveLiquidity() external payable;\\n    function lockETH() external payable;\\n    function unlockETH(uint256 _value) external;\\n    function authorizePortal(IOptimismPortal2 _portal) external;\\n    function authorizeLockbox(IETHLockbox _lockbox) external;\\n    function migrateLiquidity(IETHLockbox _lockbox) external;\\n    function superchainConfig() external view returns (ISuperchainConfig);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IOptimismPortal2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { GameType } from \\\"src/dispute/lib/LibUDT.sol\\\";\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { IDisputeGameFactory } from \\\"interfaces/dispute/IDisputeGameFactory.sol\\\";\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IAnchorStateRegistry } from \\\"interfaces/dispute/IAnchorStateRegistry.sol\\\";\\nimport { IProxyAdminOwnedBase } from \\\"interfaces/L1/IProxyAdminOwnedBase.sol\\\";\\nimport { IETHLockbox } from \\\"interfaces/L1/IETHLockbox.sol\\\";\\n\\ninterface IOptimismPortal2 is IProxyAdminOwnedBase {\\n    error OptimismPortal_Unauthorized();\\n    error ContentLengthMismatch();\\n    error EmptyItem();\\n    error InvalidDataRemainder();\\n    error InvalidHeader();\\n    error ReinitializableBase_ZeroInitVersion();\\n    error OptimismPortal_AlreadyFinalized();\\n    error OptimismPortal_BadTarget();\\n    error OptimismPortal_CallPaused();\\n    error OptimismPortal_CalldataTooLarge();\\n    error OptimismPortal_GasEstimation();\\n    error OptimismPortal_GasLimitTooLow();\\n    error OptimismPortal_ImproperDisputeGame();\\n    error OptimismPortal_InvalidDisputeGame();\\n    error OptimismPortal_InvalidMerkleProof();\\n    error OptimismPortal_InvalidOutputRootProof();\\n    error OptimismPortal_InvalidProofTimestamp();\\n    error OptimismPortal_InvalidRootClaim();\\n    error OptimismPortal_NoReentrancy();\\n    error OptimismPortal_ProofNotOldEnough();\\n    error OptimismPortal_Unproven();\\n    error OptimismPortal_InvalidOutputRootIndex();\\n    error OptimismPortal_InvalidSuperRootProof();\\n    error OptimismPortal_InvalidOutputRootChainId();\\n    error OptimismPortal_WrongProofMethod();\\n    error OptimismPortal_MigratingToSameRegistry();\\n    error Encoding_EmptySuperRoot();\\n    error Encoding_InvalidSuperRootVersion();\\n    error OutOfGas();\\n    error UnexpectedList();\\n    error UnexpectedString();\\n\\n    event Initialized(uint8 version);\\n    event TransactionDeposited(address indexed from, address indexed to, uint256 indexed version, bytes opaqueData);\\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\\n    event WithdrawalProven(bytes32 indexed withdrawalHash, address indexed from, address indexed to);\\n    event WithdrawalProvenExtension1(bytes32 indexed withdrawalHash, address indexed proofSubmitter);\\n    event ETHMigrated(address indexed lockbox, uint256 ethBalance);\\n    event PortalMigrated(IETHLockbox oldLockbox, IETHLockbox newLockbox, IAnchorStateRegistry oldAnchorStateRegistry, IAnchorStateRegistry newAnchorStateRegistry);\\n\\n    receive() external payable;\\n\\n    function anchorStateRegistry() external view returns (IAnchorStateRegistry);\\n    function ethLockbox() external view returns (IETHLockbox);\\n    function checkWithdrawal(bytes32 _withdrawalHash, address _proofSubmitter) external view;\\n    function depositTransaction(\\n        address _to,\\n        uint256 _value,\\n        uint64 _gasLimit,\\n        bool _isCreation,\\n        bytes memory _data\\n    )\\n        external\\n        payable;\\n    function disputeGameBlacklist(IDisputeGame _disputeGame) external view returns (bool);\\n    function disputeGameFactory() external view returns (IDisputeGameFactory);\\n    function disputeGameFinalityDelaySeconds() external view returns (uint256);\\n    function donateETH() external payable;\\n    function superchainConfig() external view returns (ISuperchainConfig);\\n    function migrateToSuperRoots(IETHLockbox _newLockbox, IAnchorStateRegistry _newAnchorStateRegistry) external;\\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx) external;\\n    function finalizeWithdrawalTransactionExternalProof(\\n        Types.WithdrawalTransaction memory _tx,\\n        address _proofSubmitter\\n    )\\n        external;\\n    function finalizedWithdrawals(bytes32) external view returns (bool);\\n    function guardian() external view returns (address);\\n    function initialize(\\n        ISystemConfig _systemConfig,\\n        IAnchorStateRegistry _anchorStateRegistry,\\n        IETHLockbox _ethLockbox\\n    )\\n        external;\\n    function initVersion() external view returns (uint8);\\n    function l2Sender() external view returns (address);\\n    function minimumGasLimit(uint64 _byteCount) external pure returns (uint64);\\n    function numProofSubmitters(bytes32 _withdrawalHash) external view returns (uint256);\\n    function params() external view returns (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum); // nosemgrep\\n    function paused() external view returns (bool);\\n    function proofMaturityDelaySeconds() external view returns (uint256);\\n    function proofSubmitters(bytes32, uint256) external view returns (address);\\n    function proveWithdrawalTransaction(\\n        Types.WithdrawalTransaction memory _tx,\\n        uint256 _disputeGameIndex,\\n        Types.OutputRootProof memory _outputRootProof,\\n        bytes[] memory _withdrawalProof\\n    )\\n        external;\\n    function proveWithdrawalTransaction(\\n        Types.WithdrawalTransaction memory _tx,\\n        IDisputeGame _disputeGameProxy,\\n        uint256 _outputRootIndex,\\n        Types.SuperRootProof memory _superRootProof,\\n        Types.OutputRootProof memory _outputRootProof,\\n        bytes[] memory _withdrawalProof\\n    )\\n        external;\\n    function provenWithdrawals(\\n        bytes32,\\n        address\\n    )\\n        external\\n        view\\n        returns (IDisputeGame disputeGameProxy, uint64 timestamp);\\n    function respectedGameType() external view returns (GameType);\\n    function respectedGameTypeUpdatedAt() external view returns (uint64);\\n    function superRootsActive() external view returns (bool);\\n    function systemConfig() external view returns (ISystemConfig);\\n    function upgrade(IAnchorStateRegistry _anchorStateRegistry, IETHLockbox _ethLockbox) external;\\n    function version() external pure returns (string memory);\\n    function migrateLiquidity() external;\\n\\n    function __constructor__(uint256 _proofMaturityDelaySeconds) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IProxyAdminOwnedBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IProxyAdmin } from \\\"interfaces/universal/IProxyAdmin.sol\\\";\\n\\ninterface IProxyAdminOwnedBase {\\n    error ProxyAdminOwnedBase_NotSharedProxyAdminOwner();\\n    error ProxyAdminOwnedBase_NotProxyAdminOwner();\\n    error ProxyAdminOwnedBase_NotProxyAdmin();\\n    error ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner();\\n    error ProxyAdminOwnedBase_ProxyAdminNotFound();\\n    error ProxyAdminOwnedBase_NotResolvedDelegateProxy();\\n\\n    function proxyAdmin() external view returns (IProxyAdmin);\\n    function proxyAdminOwner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/IResourceMetering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IResourceMetering {\\n    struct ResourceParams {\\n        uint128 prevBaseFee;\\n        uint64 prevBoughtGas;\\n        uint64 prevBlockNum;\\n    }\\n\\n    struct ResourceConfig {\\n        uint32 maxResourceLimit;\\n        uint8 elasticityMultiplier;\\n        uint8 baseFeeMaxChangeDenominator;\\n        uint32 minimumBaseFee;\\n        uint32 systemTxMaxGas;\\n        uint128 maximumBaseFee;\\n    }\\n\\n    error OutOfGas();\\n\\n    event Initialized(uint8 version);\\n\\n    function params() external view returns (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum); // nosemgrep\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISuperchainConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IProxyAdminOwnedBase } from \\\"interfaces/L1/IProxyAdminOwnedBase.sol\\\";\\n\\ninterface ISuperchainConfig is IProxyAdminOwnedBase {\\n    enum UpdateType {\\n        GUARDIAN\\n    }\\n\\n    event ConfigUpdate(UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event Paused(address identifier);\\n    event Unpaused(address identifier);\\n\\n    error SuperchainConfig_OnlyGuardian();\\n    error SuperchainConfig_AlreadyPaused(address identifier);\\n    error SuperchainConfig_NotAlreadyPaused(address identifier);\\n    error ReinitializableBase_ZeroInitVersion();\\n\\n    function guardian() external view returns (address);\\n    function initialize(address _guardian) external;\\n    function upgrade() external;\\n    function pause(address _identifier) external;\\n    function unpause(address _identifier) external;\\n    function pausable(address _identifier) external view returns (bool);\\n    function paused() external view returns (bool);\\n    function paused(address _identifier) external view returns (bool);\\n    function expiration(address _identifier) external view returns (uint256);\\n    function extend(address _identifier) external;\\n    function version() external view returns (string memory);\\n    function pauseTimestamps(address) external view returns (uint256);\\n    function pauseExpiry() external view returns (uint256);\\n    function initVersion() external view returns (uint8);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/L1/ISystemConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IProxyAdminOwnedBase } from \\\"interfaces/L1/IProxyAdminOwnedBase.sol\\\";\\n\\ninterface ISystemConfig is IProxyAdminOwnedBase {\\n    enum UpdateType {\\n        BATCHER,\\n        FEE_SCALARS,\\n        GAS_LIMIT,\\n        UNSAFE_BLOCK_SIGNER,\\n        EIP_1559_PARAMS,\\n        OPERATOR_FEE_PARAMS\\n    }\\n\\n    struct Addresses {\\n        address l1CrossDomainMessenger;\\n        address l1ERC721Bridge;\\n        address l1StandardBridge;\\n        address optimismPortal;\\n        address optimismMintableERC20Factory;\\n    }\\n\\n    error ReinitializableBase_ZeroInitVersion();\\n\\n    event ConfigUpdate(uint256 indexed version, UpdateType indexed updateType, bytes data);\\n    event Initialized(uint8 version);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function BATCH_INBOX_SLOT() external view returns (bytes32);\\n    function L1_CROSS_DOMAIN_MESSENGER_SLOT() external view returns (bytes32);\\n    function L1_ERC_721_BRIDGE_SLOT() external view returns (bytes32);\\n    function L1_STANDARD_BRIDGE_SLOT() external view returns (bytes32);\\n    function OPTIMISM_MINTABLE_ERC20_FACTORY_SLOT() external view returns (bytes32);\\n    function OPTIMISM_PORTAL_SLOT() external view returns (bytes32);\\n    function START_BLOCK_SLOT() external view returns (bytes32);\\n    function UNSAFE_BLOCK_SIGNER_SLOT() external view returns (bytes32);\\n    function VERSION() external view returns (uint256);\\n    function basefeeScalar() external view returns (uint32);\\n    function batchInbox() external view returns (address addr_);\\n    function batcherHash() external view returns (bytes32);\\n    function blobbasefeeScalar() external view returns (uint32);\\n    function disputeGameFactory() external view returns (address addr_);\\n    function gasLimit() external view returns (uint64);\\n    function eip1559Denominator() external view returns (uint32);\\n    function eip1559Elasticity() external view returns (uint32);\\n    function getAddresses() external view returns (Addresses memory);\\n    function initialize(\\n        address _owner,\\n        uint32 _basefeeScalar,\\n        uint32 _blobbasefeeScalar,\\n        bytes32 _batcherHash,\\n        uint64 _gasLimit,\\n        address _unsafeBlockSigner,\\n        IResourceMetering.ResourceConfig memory _config,\\n        address _batchInbox,\\n        Addresses memory _addresses,\\n        uint256 _l2ChainId,\\n        ISuperchainConfig _superchainConfig\\n    )\\n        external;\\n    function initVersion() external view returns (uint8);\\n    function l1CrossDomainMessenger() external view returns (address addr_);\\n    function l1ERC721Bridge() external view returns (address addr_);\\n    function l1StandardBridge() external view returns (address addr_);\\n    function l2ChainId() external view returns (uint256);\\n    function maximumGasLimit() external pure returns (uint64);\\n    function minimumGasLimit() external view returns (uint64);\\n    function operatorFeeConstant() external view returns (uint64);\\n    function operatorFeeScalar() external view returns (uint32);\\n    function optimismMintableERC20Factory() external view returns (address addr_);\\n    function optimismPortal() external view returns (address addr_);\\n    function overhead() external view returns (uint256);\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function resourceConfig() external view returns (IResourceMetering.ResourceConfig memory);\\n    function scalar() external view returns (uint256);\\n    function setBatcherHash(bytes32 _batcherHash) external;\\n    function setGasConfig(uint256 _overhead, uint256 _scalar) external;\\n    function setGasConfigEcotone(uint32 _basefeeScalar, uint32 _blobbasefeeScalar) external;\\n    function setGasLimit(uint64 _gasLimit) external;\\n    function setOperatorFeeScalars(uint32 _operatorFeeScalar, uint64 _operatorFeeConstant) external;\\n    function setUnsafeBlockSigner(address _unsafeBlockSigner) external;\\n    function setEIP1559Params(uint32 _denominator, uint32 _elasticity) external;\\n    function startBlock() external view returns (uint256 startBlock_);\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function unsafeBlockSigner() external view returns (address addr_);\\n    function upgrade(uint256 _l2ChainId, ISuperchainConfig _superchainConfig) external;\\n    function version() external pure returns (string memory);\\n    function paused() external view returns (bool);\\n    function superchainConfig() external view returns (ISuperchainConfig);\\n    function guardian() external view returns (address);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/cannon/IPreimageOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { LibKeccak } from \\\"@lib-keccak/LibKeccak.sol\\\";\\nimport { LPPMetaData } from \\\"src/cannon/libraries/CannonTypes.sol\\\";\\n\\ninterface IPreimageOracle {\\n    struct Leaf {\\n        bytes input;\\n        uint256 index;\\n        bytes32 stateCommitment;\\n    }\\n\\n    error ActiveProposal();\\n    error AlreadyFinalized();\\n    error AlreadyInitialized();\\n    error BadProposal();\\n    error BondTransferFailed();\\n    error InsufficientBond();\\n    error InvalidInputSize();\\n    error InvalidPreimage();\\n    error InvalidProof();\\n    error NotEOA();\\n    error NotInitialized();\\n    error PartOffsetOOB();\\n    error PostStateMatches();\\n    error StatesNotContiguous();\\n    error TreeSizeOverflow();\\n    error WrongStartingBlock();\\n\\n    function KECCAK_TREE_DEPTH() external view returns (uint256);\\n    function MAX_LEAF_COUNT() external view returns (uint256);\\n    function MIN_BOND_SIZE() external view returns (uint256);\\n    function PRECOMPILE_CALL_RESERVED_GAS() external view returns (uint256);\\n    function addLeavesLPP(\\n        uint256 _uuid,\\n        uint256 _inputStartBlock,\\n        bytes memory _input,\\n        bytes32[] memory _stateCommitments,\\n        bool _finalize\\n    )\\n        external;\\n    function challengeFirstLPP(\\n        address _claimant,\\n        uint256 _uuid,\\n        Leaf memory _postState,\\n        bytes32[] memory _postStateProof\\n    )\\n        external;\\n    function challengeLPP(\\n        address _claimant,\\n        uint256 _uuid,\\n        LibKeccak.StateMatrix memory _stateMatrix,\\n        Leaf memory _preState,\\n        bytes32[] memory _preStateProof,\\n        Leaf memory _postState,\\n        bytes32[] memory _postStateProof\\n    )\\n        external;\\n    function challengePeriod() external view returns (uint256 challengePeriod_);\\n    function getTreeRootLPP(address _owner, uint256 _uuid) external view returns (bytes32 treeRoot_);\\n    function initLPP(uint256 _uuid, uint32 _partOffset, uint32 _claimedSize) external payable;\\n    function loadBlobPreimagePart(\\n        uint256 _z,\\n        uint256 _y,\\n        bytes memory _commitment,\\n        bytes memory _proof,\\n        uint256 _partOffset\\n    )\\n        external;\\n    function loadKeccak256PreimagePart(uint256 _partOffset, bytes memory _preimage) external;\\n    function loadLocalData(\\n        uint256 _ident,\\n        bytes32 _localContext,\\n        bytes32 _word,\\n        uint256 _size,\\n        uint256 _partOffset\\n    )\\n        external\\n        returns (bytes32 key_);\\n    function loadPrecompilePreimagePart(\\n        uint256 _partOffset,\\n        address _precompile,\\n        uint64 _requiredGas,\\n        bytes memory _input\\n    )\\n        external;\\n    function loadSha256PreimagePart(uint256 _partOffset, bytes memory _preimage) external;\\n    function minProposalSize() external view returns (uint256 minProposalSize_);\\n    function preimageLengths(bytes32) external view returns (uint256);\\n    function preimagePartOk(bytes32, uint256) external view returns (bool);\\n    function preimageParts(bytes32, uint256) external view returns (bytes32);\\n    function proposalBlocks(address, uint256, uint256) external view returns (uint64);\\n    function proposalBlocksLen(address _claimant, uint256 _uuid) external view returns (uint256 len_);\\n    function proposalBonds(address, uint256) external view returns (uint256);\\n    function proposalBranches(address, uint256, uint256) external view returns (bytes32);\\n    function proposalCount() external view returns (uint256 count_);\\n    function proposalMetadata(address, uint256) external view returns (LPPMetaData);\\n    function proposalParts(address, uint256) external view returns (bytes32);\\n    function proposals(uint256) external view returns (address claimant, uint256 uuid); // nosemgrep:\\n        // sol-style-return-arg-fmt\\n    function readPreimage(bytes32 _key, uint256 _offset) external view returns (bytes32 dat_, uint256 datLen_);\\n    function squeezeLPP(\\n        address _claimant,\\n        uint256 _uuid,\\n        LibKeccak.StateMatrix memory _stateMatrix,\\n        Leaf memory _preState,\\n        bytes32[] memory _preStateProof,\\n        Leaf memory _postState,\\n        bytes32[] memory _postStateProof\\n    )\\n        external;\\n    function version() external view returns (string memory);\\n    function zeroHashes(uint256) external view returns (bytes32);\\n\\n    function __constructor__(uint256 _minProposalSize, uint256 _challengePeriod) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IAnchorStateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { IFaultDisputeGame } from \\\"interfaces/dispute/IFaultDisputeGame.sol\\\";\\nimport { IDisputeGameFactory } from \\\"interfaces/dispute/IDisputeGameFactory.sol\\\";\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { GameType, Hash, Proposal } from \\\"src/dispute/lib/Types.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IProxyAdminOwnedBase } from \\\"interfaces/L1/IProxyAdminOwnedBase.sol\\\";\\n\\ninterface IAnchorStateRegistry is IProxyAdminOwnedBase {\\n    error AnchorStateRegistry_InvalidAnchorGame();\\n    error AnchorStateRegistry_Unauthorized();\\n    error ReinitializableBase_ZeroInitVersion();\\n\\n    event AnchorUpdated(IFaultDisputeGame indexed game);\\n    event DisputeGameBlacklisted(IDisputeGame indexed disputeGame);\\n    event Initialized(uint8 version);\\n    event RespectedGameTypeSet(GameType gameType);\\n    event RetirementTimestampSet(uint256 timestamp);\\n\\n    function initVersion() external view returns (uint8);\\n    function anchorGame() external view returns (IFaultDisputeGame);\\n    function anchors(GameType) external view returns (Hash, uint256);\\n    function blacklistDisputeGame(IDisputeGame _disputeGame) external;\\n    function disputeGameBlacklist(IDisputeGame) external view returns (bool);\\n    function getAnchorRoot() external view returns (Hash, uint256);\\n    function disputeGameFinalityDelaySeconds() external view returns (uint256);\\n    function disputeGameFactory() external view returns (IDisputeGameFactory);\\n    function initialize(\\n        ISystemConfig _systemConfig,\\n        IDisputeGameFactory _disputeGameFactory,\\n        Proposal memory _startingAnchorRoot,\\n        GameType _startingRespectedGameType\\n    )\\n        external;\\n    function isGameBlacklisted(IDisputeGame _game) external view returns (bool);\\n    function isGameProper(IDisputeGame _game) external view returns (bool);\\n    function isGameRegistered(IDisputeGame _game) external view returns (bool);\\n    function isGameResolved(IDisputeGame _game) external view returns (bool);\\n    function isGameRespected(IDisputeGame _game) external view returns (bool);\\n    function isGameRetired(IDisputeGame _game) external view returns (bool);\\n    function isGameFinalized(IDisputeGame _game) external view returns (bool);\\n    function isGameClaimValid(IDisputeGame _game) external view returns (bool);\\n    function paused() external view returns (bool);\\n    function respectedGameType() external view returns (GameType);\\n    function retirementTimestamp() external view returns (uint64);\\n    function setAnchorState(IDisputeGame _game) external;\\n    function setRespectedGameType(GameType _gameType) external;\\n    function systemConfig() external view returns (ISystemConfig);\\n    function updateRetirementTimestamp() external;\\n    function version() external view returns (string memory);\\n    function superchainConfig() external view returns (ISuperchainConfig);\\n\\n    function __constructor__(\\n        uint256 _disputeGameFinalityDelaySeconds\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IBigStepper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IPreimageOracle } from \\\"interfaces/cannon/IPreimageOracle.sol\\\";\\n\\n/// @title IBigStepper\\n/// @notice Describes a state machine that can perform a single instruction step, provided a prestate and an optional\\n///         proof.\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fc\u2836\u2885\u2812\u2884\u2894\u28f6\u2866\u28e4\u2864\u2804\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2828\u284f\u2800\u2800\u2808\u2822\u28d9\u28af\u28c4\u2800\u28a8\u282f\u287a\u2858\u2884\u2800\u2800\u2800\u2800\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28f6\u2846\u2800\u2800\u2800\u2800\u2808\u2813\u282c\u2852\u2821\u28c0\u2899\u285c\u2840\u2813\u2804\u2800\u2800\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2877\u283f\u28e7\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2809\u2823\u28de\u2829\u2825\u2800\u283c\u2884\u2800\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2847\u2800\u2800\u2800\u2809\u28b9\u28f6\u2812\u2812\u2802\u2808\u2809\u2801\u2818\u2846\u2800\u28ff\u28ff\u282b\u2844\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u28b6\u28e4\u28c0\u2840\u2800\u2800\u28b8\u287f\u2800\u2800\u2800\u2800\u2800\u2880\u281e\u2800\u2800\u28a1\u28a8\u2880\u2844\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u2852\u28ff\u28bf\u2864\u281d\u2863\u2809\u2801\u281a\u281b\u2800\u2824\u2824\u28c4\u2870\u2801\u2800\u2800\u2800\u2809\u2819\u28b8\u2800\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2864\u28af\u284c\u287f\u2847\u2818\u2877\u2800\u2801\u2800\u2800\u2880\u28f0\u2822\u2832\u281b\u28c8\u28f8\u2826\u2824\u2836\u2834\u28ac\u28d0\u28ca\u2842\u2800\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e4\u286a\u2857\u28ab\u281e\u2800\u2806\u28c0\u283b\u2824\u2834\u2810\u281a\u28c9\u2880\u2826\u2802\u280b\u2801\u2800\u2801\u2800\u2800\u2800\u2800\u288b\u2809\u2807\u2800\\n/// \u2800\u2800\u2800\u2800\u28c0\u2864\u2810\u2812\u2818\u2879\u2809\u28b8\u2807\u2838\u2800\u2800\u2800\u2800\u28c0\u28e4\u2834\u281a\u2809\u2808\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u283c\u2800\u28fe\u2800\\n/// \u2800\u2800\u2800\u2870\u2800\u2809\u2809\u2800\u2801\u2800\u2800\u2808\u2887\u2808\u2812\u2812\u2818\u2808\u2880\u28a1\u2842\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b0\u2800\u28b8\u2844\\n/// \u2800\u2800\u2838\u28ff\u28c6\u2824\u2880\u2840\u2800\u2800\u2800\u2800\u2898\u284c\u2800\u2800\u28c0\u28c0\u28c0\u2848\u28e4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2800\u28b8\u2847\\n/// \u2800\u2800\u28b8\u28c0\u2800\u2809\u2812\u2810\u281b\u280b\u282d\u282d\u280d\u2809\u281b\u2812\u2812\u2812\u2800\u2812\u281a\u281b\u281b\u281b\u2829\u282d\u282d\u282d\u282d\u2824\u2824\u2824\u2824\u2824\u282d\u282d\u2809\u2813\u2846\\n/// \u2800\u2800\u2818\u283f\u28f7\u28f6\u28e4\u28e4\u28c0\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u28e4\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2847\\n/// \u2800\u2800\u2800\u2800\u2800\u2809\u2819\u281b\u281b\u283b\u283f\u28bf\u28ff\u28ff\u28f7\u28f6\u28f6\u28f6\u28e4\u28e4\u28c0\u28c1\u28db\u28c3\u28d2\u283f\u283f\u283f\u2824\u2820\u2804\u2824\u2824\u28a4\u28db\u28d3\u28c2\u28fb\u2847\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2809\u2809\u2809\u2819\u281b\u283b\u283f\u283f\u283f\u28bf\u28ff\u28ff\u28ff\u28f7\u28f6\u28f6\u28fe\u28ff\u28ff\u28ff\u28ff\u283f\u281f\u2801\\n/// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2808\u2809\u2809\u2809\u2809\u2801\u2800\u2800\u2800\u2800\u2800\\ninterface IBigStepper {\\n    /// @notice Performs the state transition from a given prestate and returns the hash of the post state witness.\\n    /// @param _stateData The raw opaque prestate data.\\n    /// @param _proof Opaque proof data, can be used to prove things about the prestate in relation to the state of the\\n    ///               interface's implementation.\\n    /// @param _localContext The local key context for the preimage oracle. Optional, can be set as a constant if the\\n    ///                      implementation only requires one set of local keys.\\n    /// @return postState_ The hash of the post state witness after the state transition.\\n    function step(\\n        bytes calldata _stateData,\\n        bytes calldata _proof,\\n        bytes32 _localContext\\n    )\\n        external\\n        returns (bytes32 postState_);\\n\\n    /// @notice Returns the preimage oracle used by the state machine.\\n    function oracle() external view returns (IPreimageOracle oracle_);\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDelayedWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { IProxyAdmin } from \\\"interfaces/universal/IProxyAdmin.sol\\\";\\n\\ninterface IDelayedWETH {\\n    error ProxyAdminOwnedBase_NotSharedProxyAdminOwner();\\n    error ProxyAdminOwnedBase_NotProxyAdminOwner();\\n    error ProxyAdminOwnedBase_NotProxyAdmin();\\n    error ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner();\\n    error ProxyAdminOwnedBase_ProxyAdminNotFound();\\n    error ProxyAdminOwnedBase_NotResolvedDelegateProxy();\\n    error ReinitializableBase_ZeroInitVersion();\\n\\n    struct WithdrawalRequest {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    event Initialized(uint8 version);\\n\\n    fallback() external payable;\\n    receive() external payable;\\n\\n    function initVersion() external view returns (uint8);\\n    function systemConfig() external view returns (ISystemConfig);\\n    function delay() external view returns (uint256);\\n    function hold(address _guy) external;\\n    function hold(address _guy, uint256 _wad) external;\\n    function initialize(ISystemConfig _systemConfig) external;\\n    function recover(uint256 _wad) external;\\n    function unlock(address _guy, uint256 _wad) external;\\n    function withdraw(address _guy, uint256 _wad) external;\\n    function withdrawals(address, address) external view returns (uint256 amount, uint256 timestamp);\\n    function version() external view returns (string memory);\\n    function proxyAdmin() external view returns (IProxyAdmin);\\n    function proxyAdminOwner() external view returns (address);\\n    function withdraw(uint256 _wad) external;\\n\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n\\n    event Deposit(address indexed dst, uint256 wad);\\n\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address src) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function deposit() external payable;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\\n\\n    function config() external view returns (ISuperchainConfig);\\n\\n    function __constructor__(uint256 _delay) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDisputeGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IInitializable } from \\\"interfaces/dispute/IInitializable.sol\\\";\\nimport { Timestamp, GameStatus, GameType, Claim, Hash } from \\\"src/dispute/lib/Types.sol\\\";\\n\\ninterface IDisputeGame is IInitializable {\\n    event Resolved(GameStatus indexed status);\\n\\n    function createdAt() external view returns (Timestamp);\\n    function resolvedAt() external view returns (Timestamp);\\n    function status() external view returns (GameStatus);\\n    function gameType() external view returns (GameType gameType_);\\n    function gameCreator() external pure returns (address creator_);\\n    function rootClaim() external pure returns (Claim rootClaim_);\\n    function l1Head() external pure returns (Hash l1Head_);\\n    function l2SequenceNumber() external pure returns (uint256 l2SequenceNumber_);\\n    function extraData() external pure returns (bytes memory extraData_);\\n    function resolve() external returns (GameStatus status_);\\n    function gameData() external view returns (GameType gameType_, Claim rootClaim_, bytes memory extraData_);\\n    function wasRespectedGameTypeWhenCreated() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IDisputeGameFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { GameId, Timestamp, Claim, Hash, GameType } from \\\"src/dispute/lib/Types.sol\\\";\\nimport { IProxyAdminOwnedBase } from \\\"interfaces/L1/IProxyAdminOwnedBase.sol\\\";\\nimport { IReinitializableBase } from \\\"interfaces/universal/IReinitializableBase.sol\\\";\\n\\ninterface IDisputeGameFactory is IProxyAdminOwnedBase, IReinitializableBase {\\n    struct GameSearchResult {\\n        uint256 index;\\n        GameId metadata;\\n        Timestamp timestamp;\\n        Claim rootClaim;\\n        bytes extraData;\\n    }\\n\\n    error GameAlreadyExists(Hash uuid);\\n    error IncorrectBondAmount();\\n    error NoImplementation(GameType gameType);\\n\\n    event DisputeGameCreated(address indexed disputeProxy, GameType indexed gameType, Claim indexed rootClaim);\\n    event ImplementationSet(address indexed impl, GameType indexed gameType);\\n    event InitBondUpdated(GameType indexed gameType, uint256 indexed newBond);\\n    event Initialized(uint8 version);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function create(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        payable\\n        returns (IDisputeGame proxy_);\\n    function findLatestGames(\\n        GameType _gameType,\\n        uint256 _start,\\n        uint256 _n\\n    )\\n        external\\n        view\\n        returns (GameSearchResult[] memory games_);\\n    function gameAtIndex(uint256 _index)\\n        external\\n        view\\n        returns (GameType gameType_, Timestamp timestamp_, IDisputeGame proxy_);\\n    function gameCount() external view returns (uint256 gameCount_);\\n    function gameImpls(GameType) external view returns (IDisputeGame);\\n    function games(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        view\\n        returns (IDisputeGame proxy_, Timestamp timestamp_);\\n    function getGameUUID(\\n        GameType _gameType,\\n        Claim _rootClaim,\\n        bytes memory _extraData\\n    )\\n        external\\n        pure\\n        returns (Hash uuid_);\\n    function initBonds(GameType) external view returns (uint256);\\n    function initialize(address _owner) external;\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function setImplementation(GameType _gameType, IDisputeGame _impl) external;\\n    function setInitBond(GameType _gameType, uint256 _initBond) external;\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function version() external view returns (string memory);\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IFaultDisputeGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IDisputeGame } from \\\"interfaces/dispute/IDisputeGame.sol\\\";\\nimport { IDelayedWETH } from \\\"interfaces/dispute/IDelayedWETH.sol\\\";\\nimport { IAnchorStateRegistry } from \\\"interfaces/dispute/IAnchorStateRegistry.sol\\\";\\nimport { IBigStepper } from \\\"interfaces/dispute/IBigStepper.sol\\\";\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { GameType, Claim, Position, Clock, Hash, Duration, BondDistributionMode } from \\\"src/dispute/lib/Types.sol\\\";\\n\\ninterface IFaultDisputeGame is IDisputeGame {\\n    struct ClaimData {\\n        uint32 parentIndex;\\n        address counteredBy;\\n        address claimant;\\n        uint128 bond;\\n        Claim claim;\\n        Position position;\\n        Clock clock;\\n    }\\n\\n    struct ResolutionCheckpoint {\\n        bool initialCheckpointComplete;\\n        uint32 subgameIndex;\\n        Position leftmostPosition;\\n        address counteredBy;\\n    }\\n\\n    struct GameConstructorParams {\\n        GameType gameType;\\n        Claim absolutePrestate;\\n        uint256 maxGameDepth;\\n        uint256 splitDepth;\\n        Duration clockExtension;\\n        Duration maxClockDuration;\\n        IBigStepper vm;\\n        IDelayedWETH weth;\\n        IAnchorStateRegistry anchorStateRegistry;\\n        uint256 l2ChainId;\\n    }\\n\\n    error AlreadyInitialized();\\n    error AnchorRootNotFound();\\n    error BlockNumberMatches();\\n    error BondTransferFailed();\\n    error CannotDefendRootClaim();\\n    error ClaimAboveSplit();\\n    error ClaimAlreadyExists();\\n    error ClaimAlreadyResolved();\\n    error ClockNotExpired();\\n    error ClockTimeExceeded();\\n    error ContentLengthMismatch();\\n    error DuplicateStep();\\n    error EmptyItem();\\n    error GameDepthExceeded();\\n    error GameNotInProgress();\\n    error IncorrectBondAmount();\\n    error InvalidChallengePeriod();\\n    error InvalidClockExtension();\\n    error InvalidDataRemainder();\\n    error InvalidDisputedClaimIndex();\\n    error InvalidHeader();\\n    error InvalidHeaderRLP();\\n    error InvalidLocalIdent();\\n    error InvalidOutputRootProof();\\n    error InvalidParent();\\n    error InvalidPrestate();\\n    error InvalidSplitDepth();\\n    error L2BlockNumberChallenged();\\n    error MaxDepthTooLarge();\\n    error NoCreditToClaim();\\n    error OutOfOrderResolution();\\n    error UnexpectedList();\\n    error UnexpectedRootClaim(Claim rootClaim);\\n    error UnexpectedString();\\n    error ValidStep();\\n    error InvalidBondDistributionMode();\\n    error GameNotFinalized();\\n    error GameNotResolved();\\n    error ReservedGameType();\\n    error GamePaused();\\n    event Move(uint256 indexed parentIndex, Claim indexed claim, address indexed claimant);\\n    event GameClosed(BondDistributionMode bondDistributionMode);\\n\\n    function absolutePrestate() external view returns (Claim absolutePrestate_);\\n    function addLocalData(uint256 _ident, uint256 _execLeafIdx, uint256 _partOffset) external;\\n    function anchorStateRegistry() external view returns (IAnchorStateRegistry registry_);\\n    function attack(Claim _disputed, uint256 _parentIndex, Claim _claim) external payable;\\n    function bondDistributionMode() external view returns (BondDistributionMode);\\n    function challengeRootL2Block(Types.OutputRootProof memory _outputRootProof, bytes memory _headerRLP) external;\\n    function claimCredit(address _recipient) external;\\n    function claimData(uint256)\\n        external\\n        view // nosemgrep\\n        returns (\\n            uint32 parentIndex,\\n            address counteredBy,\\n            address claimant,\\n            uint128 bond,\\n            Claim claim,\\n            Position position,\\n            Clock clock\\n        );\\n    function claimDataLen() external view returns (uint256 len_);\\n    function claims(Hash) external view returns (bool);\\n    function clockExtension() external view returns (Duration clockExtension_);\\n    function closeGame() external;\\n    function credit(address _recipient) external view returns (uint256 credit_);\\n    function defend(Claim _disputed, uint256 _parentIndex, Claim _claim) external payable;\\n    function getChallengerDuration(uint256 _claimIndex) external view returns (Duration duration_);\\n    function getNumToResolve(uint256 _claimIndex) external view returns (uint256 numRemainingChildren_);\\n    function getRequiredBond(Position _position) external view returns (uint256 requiredBond_);\\n    function hasUnlockedCredit(address) external view returns (bool);\\n    function l2BlockNumber() external pure returns (uint256 l2BlockNumber_);\\n    function l2BlockNumberChallenged() external view returns (bool);\\n    function l2BlockNumberChallenger() external view returns (address);\\n    function l2ChainId() external view returns (uint256 l2ChainId_);\\n    function maxClockDuration() external view returns (Duration maxClockDuration_);\\n    function maxGameDepth() external view returns (uint256 maxGameDepth_);\\n    function move(Claim _disputed, uint256 _challengeIndex, Claim _claim, bool _isAttack) external payable;\\n    function normalModeCredit(address) external view returns (uint256);\\n    function refundModeCredit(address) external view returns (uint256);\\n    function resolutionCheckpoints(uint256)\\n        external\\n        view\\n        returns (bool initialCheckpointComplete, uint32 subgameIndex, Position leftmostPosition, address counteredBy); // nosemgrep\\n    function resolveClaim(uint256 _claimIndex, uint256 _numToResolve) external;\\n    function resolvedSubgames(uint256) external view returns (bool);\\n    function splitDepth() external view returns (uint256 splitDepth_);\\n    function startingBlockNumber() external view returns (uint256 startingBlockNumber_);\\n    function startingOutputRoot() external view returns (Hash root, uint256 l2SequenceNumber); // nosemgrep\\n    function startingRootHash() external view returns (Hash startingRootHash_);\\n    function step(uint256 _claimIndex, bool _isAttack, bytes memory _stateData, bytes memory _proof) external;\\n    function subgames(uint256, uint256) external view returns (uint256);\\n    function version() external pure returns (string memory);\\n    function vm() external view returns (IBigStepper vm_);\\n    function wasRespectedGameTypeWhenCreated() external view returns (bool);\\n    function weth() external view returns (IDelayedWETH weth_);\\n\\n    function __constructor__(GameConstructorParams memory _params) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/dispute/IInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInitializable {\\n    function initialize() external payable;\\n}\\n\"\r\n    },\r\n    \"interfaces/legacy/IAddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from \\\"interfaces/universal/IOwnable.sol\\\";\\n\\n/// @title IAddressManager\\n/// @notice Interface for the AddressManager contract.\\ninterface IAddressManager is IOwnable {\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    function getAddress(string memory _name) external view returns (address);\\n    function setAddress(string memory _name, address _address) external;\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title IOwnable\\n/// @notice Interface for Ownable.\\ninterface IOwnable {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n    function renounceOwnership() external;\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/IProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IAddressManager } from \\\"interfaces/legacy/IAddressManager.sol\\\";\\n\\ninterface IProxyAdmin {\\n    enum ProxyType {\\n        ERC1967,\\n        CHUGSPLASH,\\n        RESOLVED\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function addressManager() external view returns (IAddressManager);\\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external;\\n    function getProxyAdmin(address payable _proxy) external view returns (address);\\n    function getProxyImplementation(address _proxy) external view returns (address);\\n    function implementationName(address) external view returns (string memory);\\n    function isUpgrading() external view returns (bool);\\n    function owner() external view returns (address);\\n    function proxyType(address) external view returns (ProxyType);\\n    function renounceOwnership() external;\\n    function setAddress(string memory _name, address _address) external;\\n    function setAddressManager(IAddressManager _address) external;\\n    function setImplementationName(address _address, string memory _name) external;\\n    function setProxyType(address _address, ProxyType _type) external;\\n    function setUpgrading(bool _upgrading) external;\\n    function transferOwnership(address newOwner) external; // nosemgrep\\n    function upgrade(address payable _proxy, address _implementation) external;\\n    function upgradeAndCall(address payable _proxy, address _implementation, bytes memory _data) external payable;\\n\\n    function __constructor__(address _owner) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/IReinitializableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IReinitializableBase {\\n    error ReinitializableBase_ZeroInitVersion();\\n\\n    function initVersion() external view returns (uint8);\\n\\n    // ReinitializerBase is abstract, so it has no constructor in its interface.\\n    function __constructor__() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/universal/ISemver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISemver\\n/// @notice ISemver is a simple contract for ensuring that contracts are\\n///         versioned using semantic versioning.\\ninterface ISemver {\\n    /// @notice Getter for the semantic version of the contract. This is not\\n    ///         meant to be used onchain but instead meant to be used by offchain\\n    ///         tooling.\\n    /// @return Semver contract version as a string.\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/L1/L1CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Contracts\\nimport { ProxyAdminOwnedBase } from \\\"src/L1/ProxyAdminOwnedBase.sol\\\";\\nimport { ReinitializableBase } from \\\"src/universal/ReinitializableBase.sol\\\";\\nimport { CrossDomainMessenger } from \\\"src/universal/CrossDomainMessenger.sol\\\";\\n\\n// Libraries\\nimport { Predeploys } from \\\"src/libraries/Predeploys.sol\\\";\\n\\n// Interfaces\\nimport { ISemver } from \\\"interfaces/universal/ISemver.sol\\\";\\nimport { ISuperchainConfig } from \\\"interfaces/L1/ISuperchainConfig.sol\\\";\\nimport { ISystemConfig } from \\\"interfaces/L1/ISystemConfig.sol\\\";\\nimport { IOptimismPortal2 as IOptimismPortal } from \\\"interfaces/L1/IOptimismPortal2.sol\\\";\\n\\n/// @custom:proxied true\\n/// @title L1CrossDomainMessenger\\n/// @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\\n///         for sending and receiving data on the L1 side. Users are encouraged to use this\\n///         interface instead of interacting with lower-level contracts directly.\\ncontract L1CrossDomainMessenger is CrossDomainMessenger, ProxyAdminOwnedBase, ReinitializableBase, ISemver {\\n    /// @custom:legacy\\n    /// @custom:spacer superchainConfig\\n    /// @notice Spacer taking up the legacy `superchainConfig` slot.\\n    address private spacer_251_0_20;\\n\\n    /// @notice Contract of the OptimismPortal.\\n    /// @custom:network-specific\\n    IOptimismPortal public portal;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer systemConfig\\n    /// @notice Spacer taking up the legacy `systemConfig` slot.\\n    address private spacer_253_0_20;\\n\\n    /// @notice Semantic version.\\n    /// @custom:semver 2.9.0\\n    string public constant version = \\\"2.9.0\\\";\\n\\n    /// @notice Contract of the SystemConfig.\\n    ISystemConfig public systemConfig;\\n\\n    /// @notice Constructs the L1CrossDomainMessenger contract.\\n    constructor() ReinitializableBase(2) {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializes the contract.\\n    /// @param _systemConfig Contract of the SystemConfig contract on this network.\\n    /// @param _portal Contract of the OptimismPortal contract on this network.\\n    function initialize(ISystemConfig _systemConfig, IOptimismPortal _portal) external reinitializer(initVersion()) {\\n        // Initialization transactions must come from the ProxyAdmin or its owner.\\n        _assertOnlyProxyAdminOrProxyAdminOwner();\\n\\n        // Now perform initialization logic.\\n        systemConfig = _systemConfig;\\n        portal = _portal;\\n        __CrossDomainMessenger_init({ _otherMessenger: CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER) });\\n    }\\n\\n    /// @notice Upgrades the contract to have a reference to the SystemConfig.\\n    /// @param _systemConfig The new SystemConfig contract.\\n    function upgrade(ISystemConfig _systemConfig) external reinitializer(initVersion()) {\\n        // Upgrade transactions must come from the ProxyAdmin or its owner.\\n        _assertOnlyProxyAdminOrProxyAdminOwner();\\n\\n        // Now perform upgrade logic.\\n        systemConfig = _systemConfig;\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function paused() public view override returns (bool) {\\n        return systemConfig.paused();\\n    }\\n\\n    /// @notice Returns the SuperchainConfig contract.\\n    /// @return ISuperchainConfig The SuperchainConfig contract.\\n    function superchainConfig() public view returns (ISuperchainConfig) {\\n        return systemConfig.superchainConfig();\\n    }\\n\\n    /// @notice Getter function for the OptimismPortal contract on this chain.\\n    ///         Public getter is legacy and will be removed in the future. Use `portal()` instead.\\n    /// @return Contract of the OptimismPortal on this chain.\\n    /// @custom:legacy\\n    function PORTAL() external view returns (IOptimismPortal) {\\n        return portal;\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal override {\\n        portal.depositTransaction{ value: _value }({\\n            _to: _to,\\n            _value: _value,\\n            _gasLimit: _gasLimit,\\n            _isCreation: false,\\n            _data: _data\\n        });\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _isOtherMessenger() internal view override returns (bool) {\\n        return msg.sender == address(portal) && portal.l2Sender() == address(otherMessenger);\\n    }\\n\\n    /// @inheritdoc CrossDomainMessenger\\n    function _isUnsafeTarget(address _target) internal view override returns (bool) {\\n        return _target == address(this) || _target == address(portal);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/L1/ProxyAdminOwnedBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport { Storage } from \\\"src/libraries/Storage.sol\\\";\\nimport { Constants } from \\\"src/libraries/Constants.sol\\\";\\n\\n// Interfaces\\nimport { IProxyAdmin } from \\\"interfaces/universal/IProxyAdmin.sol\\\";\\nimport { IAddressManager } from \\\"interfaces/legacy/IAddressManager.sol\\\";\\n\\n/// @notice Base contract for ProxyAdmin-owned contracts. This contract is used to introspect\\n///         compatible Proxy contracts so that their ProxyAdmin and ProxyAdmin owner addresses can\\n///         be retrieved onchain. Existing Proxy contracts don't have these getters, so we need a\\n///         base contract instead.\\n/// @dev WARNING: This contract is ONLY designed to be used with either the Optimism Proxy\\n///      implementation or the Optimism ResolvedDelegateProxy implementation. It is not safe to use\\n///      this contract with any other proxy implementation.\\n///      WARNING: Multiple OP Stack chains may share the same ProxyAdmin owner address.\\nabstract contract ProxyAdminOwnedBase {\\n    /// @notice Thrown when the ProxyAdmin owner of the current contract is not the same as the\\n    ///         ProxyAdmin owner of the other Proxy address provided.\\n    error ProxyAdminOwnedBase_NotSharedProxyAdminOwner();\\n\\n    /// @notice Thrown when the caller is not the ProxyAdmin owner.\\n    error ProxyAdminOwnedBase_NotProxyAdminOwner();\\n\\n    /// @notice Thrown when the caller is not the ProxyAdmin.\\n    error ProxyAdminOwnedBase_NotProxyAdmin();\\n\\n    /// @notice Thrown when the caller is not the ProxyAdmin owner or the ProxyAdmin.\\n    error ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner();\\n\\n    /// @notice Thrown when the ProxyAdmin owner of the current contract is not found.\\n    error ProxyAdminOwnedBase_ProxyAdminNotFound();\\n\\n    /// @notice Thrown when the current contract is not a ResolvedDelegateProxy.\\n    error ProxyAdminOwnedBase_NotResolvedDelegateProxy();\\n\\n    /// @notice Getter for the owner of the ProxyAdmin.\\n    function proxyAdminOwner() public view returns (address) {\\n        return proxyAdmin().owner();\\n    }\\n\\n    /// @notice Getter for the ProxyAdmin contract that owns this Proxy contract.\\n    function proxyAdmin() public view returns (IProxyAdmin) {\\n        // First check for a non-zero address in the reserved slot.\\n        address proxyAdminAddress = Storage.getAddress(Constants.PROXY_OWNER_ADDRESS);\\n        if (proxyAdminAddress != address(0)) {\\n            return IProxyAdmin(proxyAdminAddress);\\n        }\\n\\n        // Otherwise, we'll try to read the AddressManager slot.\\n        // First we make sure this is almost certainly a ResolvedDelegateProxy. We only have a\\n        // single ResolvedDelegateProxy and it's for the L1CrossDomainMessenger, so we'll check\\n        // that the storage slot for the mapping at slot 0 returns the string\\n        // \\\"OVM_L1CrossDomainMessenger\\\". We need to use Solidity's rules for how strings are stored\\n        // in storage slots to do this.\\n        if (\\n            Storage.getBytes32(keccak256(abi.encode(address(this), uint256(0))))\\n                != bytes32(\\n                    uint256(bytes32(\\\"OVM_L1CrossDomainMessenger\\\")) | uint256(bytes(\\\"OVM_L1CrossDomainMessenger\\\").length * 2)\\n                )\\n        ) {\\n            revert ProxyAdminOwnedBase_NotResolvedDelegateProxy();\\n        }\\n\\n        // Ok, now we'll try to read the AddressManager slot.\\n        address addressManagerAddress = Storage.getAddress(keccak256(abi.encode(address(this), uint256(1))));\\n        if (addressManagerAddress != address(0)) {\\n            return IProxyAdmin(IAddressManager(addressManagerAddress).owner());\\n        }\\n\\n        // We should revert here, we couldn't find a non-zero owner address.\\n        revert ProxyAdminOwnedBase_ProxyAdminNotFound();\\n    }\\n\\n    /// @notice Reverts if the ProxyAdmin owner of the current contract is not the same as the\\n    ///         ProxyAdmin owner of the other Proxy address provided. Useful asserting that both\\n    ///         the current contract and the other Proxy share the same security model.+\\n    function _assertSharedProxyAdminOwner(address _proxy) internal view {\\n        if (proxyAdminOwner() != ProxyAdminOwnedBase(_proxy).proxyAdminOwner()) {\\n            revert ProxyAdminOwnedBase_NotSharedProxyAdminOwner();\\n        }\\n    }\\n\\n    /// @notice Reverts if the caller is not the ProxyAdmin owner.\\n    function _assertOnlyProxyAdminOwner() internal view {\\n        if (proxyAdminOwner() != msg.sender) {\\n            revert ProxyAdminOwnedBase_NotProxyAdminOwner();\\n        }\\n    }\\n\\n    /// @notice Reverts if the caller is not the ProxyAdmin.\\n    function _assertOnlyProxyAdmin() internal view {\\n        if (address(proxyAdmin()) != msg.sender) {\\n            revert ProxyAdminOwnedBase_NotProxyAdmin();\\n        }\\n    }\\n\\n    function _assertOnlyProxyAdminOrProxyAdminOwner() internal view {\\n        if (address(proxyAdmin()) != msg.sender && proxyAdminOwner() != msg.sender) {\\n            revert ProxyAdminOwnedBase_NotProxyAdminOrProxyAdminOwner();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/cannon/libraries/CannonTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nusing LPPMetadataLib for LPPMetaData global;\\n\\n/// @notice Packed LPP metadata.\\n/// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n/// \u2502 Bit Offsets \u2502                Description                 \u2502\\n/// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n/// \u2502 [0, 64)     \u2502 Timestamp (Finalized - All data available) \u2502\\n/// \u2502 [64, 96)    \u2502 Part Offset                                \u2502\\n/// \u2502 [96, 128)   \u2502 Claimed Size                               \u2502\\n/// \u2502 [128, 160)  \u2502 Blocks Processed (Inclusive of Padding)    \u2502\\n/// \u2502 [160, 192)  \u2502 Bytes Processed (Non-inclusive of Padding) \u2502\\n/// \u2502 [192, 256)  \u2502 Countered                                  \u2502\\n/// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\ntype LPPMetaData is bytes32;\\n\\n/// @notice LPP metadata UDT extension functions.\\nlibrary LPPMetadataLib {\\n    uint256 private constant U64_MASK = 0xFFFFFFFFFFFFFFFF;\\n    uint256 private constant U32_MASK = 0xFFFFFFFF;\\n\\n    function setTimestamp(LPPMetaData _self, uint64 _timestamp) internal pure returns (LPPMetaData self_) {\\n        assembly {\\n            self_ := or(shl(192, _timestamp), and(_self, not(shl(192, U64_MASK))))\\n        }\\n    }\\n\\n    function setPartOffset(LPPMetaData _self, uint32 _partOffset) internal pure returns (LPPMetaData self_) {\\n        assembly {\\n            self_ := or(shl(160, _partOffset), and(_self, not(shl(160, U32_MASK))))\\n        }\\n    }\\n\\n    function setClaimedSize(LPPMetaData _self, uint32 _claimedSize) internal pure returns (LPPMetaData self_) {\\n        assembly {\\n            self_ := or(shl(128, _claimedSize), and(_self, not(shl(128, U32_MASK))))\\n        }\\n    }\\n\\n    function setBlocksProcessed(LPPMetaData _self, uint32 _blocksProcessed) internal pure returns (LPPMetaData self_) {\\n        assembly {\\n            self_ := or(shl(96, _blocksProcessed), and(_self, not(shl(96, U32_MASK))))\\n        }\\n    }\\n\\n    function setBytesProcessed(LPPMetaData _self, uint32 _bytesProcessed) internal pure returns (LPPMetaData self_) {\\n        assembly {\\n            self_ := or(shl(64, _bytesProcessed), and(_self, not(shl(64, U32_MASK))))\\n        }\\n    }\\n\\n    function setCountered(LPPMetaData _self, bool _countered) internal pure returns (LPPMetaData self_) {\\n        assembly {\\n            self_ := or(_countered, and(_self, not(U64_MASK)))\\n        }\\n    }\\n\\n    function timestamp(LPPMetaData _self) internal pure returns (uint64 timestamp_) {\\n        assembly {\\n            timestamp_ := shr(192, _self)\\n        }\\n    }\\n\\n    function partOffset(LPPMetaData _self) internal pure returns (uint64 partOffset_) {\\n        assembly {\\n            partOffset_ := and(shr(160, _self), U32_MASK)\\n        }\\n    }\\n\\n    function claimedSize(LPPMetaData _self) internal pure returns (uint32 claimedSize_) {\\n        assembly {\\n            claimedSize_ := and(shr(128, _self), U32_MASK)\\n        }\\n    }\\n\\n    function blocksProcessed(LPPMetaData _self) internal pure returns (uint32 blocksProcessed_) {\\n        assembly {\\n            blocksProcessed_ := and(shr(96, _self), U32_MASK)\\n        }\\n    }\\n\\n    function bytesProcessed(LPPMetaData _self) internal pure returns (uint32 bytesProcessed_) {\\n        assembly {\\n            bytesProcessed_ := and(shr(64, _self), U32_MASK)\\n        }\\n    }\\n\\n    function countered(LPPMetaData _self) internal pure returns (bool countered_) {\\n        assembly {\\n            countered_ := and(_self, U64_MASK)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/LibPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nusing LibPosition for Position global;\\n\\n/// @notice A `Position` represents a position of a claim within the game tree.\\n/// @dev This is represented as a \\\"generalized index\\\" where the high-order bit\\n/// is the level in the tree and the remaining bits is a unique bit pattern, allowing\\n/// a unique identifier for each node in the tree. Mathematically, it is calculated\\n/// as 2^{depth} + indexAtDepth.\\ntype Position is uint128;\\n\\n/// @title LibPosition\\n/// @notice This library contains helper functions for working with the `Position` type.\\nlibrary LibPosition {\\n    /// @notice the `MAX_POSITION_BITLEN` is the number of bits that the `Position` type, and the implementation of\\n    ///         its behavior within this library, can safely support.\\n    uint8 internal constant MAX_POSITION_BITLEN = 126;\\n\\n    /// @notice Computes a generalized index (2^{depth} + indexAtDepth).\\n    /// @param _depth The depth of the position.\\n    /// @param _indexAtDepth The index at the depth of the position.\\n    /// @return position_ The computed generalized index.\\n    function wrap(uint8 _depth, uint128 _indexAtDepth) internal pure returns (Position position_) {\\n        assembly {\\n            // gindex = 2^{_depth} + _indexAtDepth\\n            position_ := add(shl(_depth, 1), _indexAtDepth)\\n        }\\n    }\\n\\n    /// @notice Pulls the `depth` out of a `Position` type.\\n    /// @param _position The generalized index to get the `depth` of.\\n    /// @return depth_ The `depth` of the `position` gindex.\\n    /// @custom:attribution Solady <https://github.com/Vectorized/Solady>\\n    function depth(Position _position) internal pure returns (uint8 depth_) {\\n        // Return the most significant bit offset, which signifies the depth of the gindex.\\n        assembly {\\n            depth_ := or(depth_, shl(6, lt(0xffffffffffffffff, shr(depth_, _position))))\\n            depth_ := or(depth_, shl(5, lt(0xffffffff, shr(depth_, _position))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            _position := shr(depth_, _position)\\n            _position := or(_position, shr(1, _position))\\n            _position := or(_position, shr(2, _position))\\n            _position := or(_position, shr(4, _position))\\n            _position := or(_position, shr(8, _position))\\n            _position := or(_position, shr(16, _position))\\n\\n            depth_ :=\\n                or(\\n                    depth_,\\n                    byte(\\n                        shr(251, mul(_position, shl(224, 0x07c4acdd))),\\n                        0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @notice Pulls the `indexAtDepth` out of a `Position` type.\\n    ///         The `indexAtDepth` is the left/right index of a position at a specific depth within\\n    ///         the binary tree, starting from index 0. For example, at gindex 2, the `depth` = 1\\n    ///         and the `indexAtDepth` = 0.\\n    /// @param _position The generalized index to get the `indexAtDepth` of.\\n    /// @return indexAtDepth_ The `indexAtDepth` of the `position` gindex.\\n    function indexAtDepth(Position _position) internal pure returns (uint128 indexAtDepth_) {\\n        // Return bits p_{msb-1}...p_{0}. This effectively pulls the 2^{depth} out of the gindex,\\n        // leaving only the `indexAtDepth`.\\n        uint256 msb = depth(_position);\\n        assembly {\\n            indexAtDepth_ := sub(_position, shl(msb, 1))\\n        }\\n    }\\n\\n    /// @notice Get the left child of `_position`.\\n    /// @param _position The position to get the left position of.\\n    /// @return left_ The position to the left of `position`.\\n    function left(Position _position) internal pure returns (Position left_) {\\n        assembly {\\n            left_ := shl(1, _position)\\n        }\\n    }\\n\\n    /// @notice Get the right child of `_position`\\n    /// @param _position The position to get the right position of.\\n    /// @return right_ The position to the right of `position`.\\n    function right(Position _position) internal pure returns (Position right_) {\\n        assembly {\\n            right_ := or(1, shl(1, _position))\\n        }\\n    }\\n\\n    /// @notice Get the parent position of `_position`.\\n    /// @param _position The position to get the parent position of.\\n    /// @return parent_ The parent position of `position`.\\n    function parent(Position _position) internal pure returns (Position parent_) {\\n        assembly {\\n            parent_ := shr(1, _position)\\n        }\\n    }\\n\\n    /// @notice Get the deepest, right most gindex relative to the `position`. This is equivalent to\\n    ///         calling `right` on a position until the maximum depth is reached.\\n    /// @param _position The position to get the relative deepest, right most gindex of.\\n    /// @param _maxDepth The maximum depth of the game.\\n    /// @return rightIndex_ The deepest, right most gindex relative to the `position`.\\n    function rightIndex(Position _position, uint256 _maxDepth) internal pure returns (Position rightIndex_) {\\n        uint256 msb = depth(_position);\\n        assembly {\\n            let remaining := sub(_maxDepth, msb)\\n            rightIndex_ := or(shl(remaining, _position), sub(shl(remaining, 1), 1))\\n        }\\n    }\\n\\n    /// @notice Get the deepest, right most trace index relative to the `position`. This is\\n    ///         equivalent to calling `right` on a position until the maximum depth is reached and\\n    ///         then finding its index at depth.\\n    /// @param _position The position to get the relative trace index of.\\n    /// @param _maxDepth The maximum depth of the game.\\n    /// @return traceIndex_ The trace index relative to the `position`.\\n    function traceIndex(Position _position, uint256 _maxDepth) internal pure returns (uint256 traceIndex_) {\\n        uint256 msb = depth(_position);\\n        assembly {\\n            let remaining := sub(_maxDepth, msb)\\n            traceIndex_ := sub(or(shl(remaining, _position), sub(shl(remaining, 1), 1)), shl(_maxDepth, 1))\\n        }\\n    }\\n\\n    /// @notice Gets the position of the highest ancestor of `_position` that commits to the same\\n    ///         trace index.\\n    /// @param _position The position to get the highest ancestor of.\\n    /// @return ancestor_ The highest ancestor of `position` that commits to the same trace index.\\n    function traceAncestor(Position _position) internal pure returns (Position ancestor_) {\\n        // Create a field with only the lowest unset bit of `_position` set.\\n        Position lsb;\\n        assembly {\\n            lsb := and(not(_position), add(_position, 1))\\n        }\\n        // Find the index of the lowest unset bit within the field.\\n        uint256 msb = depth(lsb);\\n        // The highest ancestor that commits to the same trace index is the original position\\n        // shifted right by the index of the lowest unset bit.\\n        assembly {\\n            let a := shr(msb, _position)\\n            // Bound the ancestor to the minimum gindex, 1.\\n            ancestor_ := or(a, iszero(a))\\n        }\\n    }\\n\\n    /// @notice Gets the position of the highest ancestor of `_position` that commits to the same\\n    ///         trace index, while still being below `_upperBoundExclusive`.\\n    /// @param _position The position to get the highest ancestor of.\\n    /// @param _upperBoundExclusive The exclusive upper depth bound, used to inform where to stop in order\\n    ///                             to not escape a sub-tree.\\n    /// @return ancestor_ The highest ancestor of `position` that commits to the same trace index.\\n    function traceAncestorBounded(\\n        Position _position,\\n        uint256 _upperBoundExclusive\\n    )\\n        internal\\n        pure\\n        returns (Position ancestor_)\\n    {\\n        // This function only works for positions that are below the upper bound.\\n        if (_position.depth() <= _upperBoundExclusive) {\\n            assembly {\\n                // Revert with `ClaimAboveSplit()`\\n                mstore(0x00, 0xb34b5c22)\\n                revert(0x1C, 0x04)\\n            }\\n        }\\n\\n        // Grab the global trace ancestor.\\n        ancestor_ = traceAncestor(_position);\\n\\n        // If the ancestor is above or at the upper bound, shift it to be below the upper bound.\\n        // This should be a special case that only covers positions that commit to the final leaf\\n        // in a sub-tree.\\n        if (ancestor_.depth() <= _upperBoundExclusive) {\\n            ancestor_ = ancestor_.rightIndex(_upperBoundExclusive + 1);\\n        }\\n    }\\n\\n    /// @notice Get the move position of `_position`, which is the left child of:\\n    ///         1. `_position` if `_isAttack` is true.\\n    ///         2. `_position | 1` if `_isAttack` is false.\\n    /// @param _position The position to get the relative attack/defense position of.\\n    /// @param _isAttack Whether or not the move is an attack move.\\n    /// @return move_ The move position relative to `position`.\\n    function move(Position _position, bool _isAttack) internal pure returns (Position move_) {\\n        assembly {\\n            move_ := shl(1, or(iszero(_isAttack), _position))\\n        }\\n    }\\n\\n    /// @notice Get the value of a `Position` type in the form of the underlying uint128.\\n    /// @param _position The position to get the value of.\\n    /// @return raw_ The value of the `position` as a uint128 type.\\n    function raw(Position _position) internal pure returns (uint128 raw_) {\\n        assembly {\\n            raw_ := _position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/LibUDT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport { Position } from \\\"src/dispute/lib/LibPosition.sol\\\";\\n\\nusing LibClaim for Claim global;\\nusing LibHash for Hash global;\\nusing LibDuration for Duration global;\\nusing LibClock for Clock global;\\nusing LibGameId for GameId global;\\nusing LibTimestamp for Timestamp global;\\nusing LibVMStatus for VMStatus global;\\nusing LibGameType for GameType global;\\n\\n/// @notice A `Clock` represents a packed `Duration` and `Timestamp`\\n/// @dev The packed layout of this type is as follows:\\n/// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n/// \u2502    Bits    \u2502     Value      \u2502\\n/// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n/// \u2502 [0, 64)    \u2502 Duration       \u2502\\n/// \u2502 [64, 128)  \u2502 Timestamp      \u2502\\n/// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\ntype Clock is uint128;\\n\\n/// @title LibClock\\n/// @notice This library contains helper functions for working with the `Clock` type.\\nlibrary LibClock {\\n    /// @notice Packs a `Duration` and `Timestamp` into a `Clock` type.\\n    /// @param _duration The `Duration` to pack into the `Clock` type.\\n    /// @param _timestamp The `Timestamp` to pack into the `Clock` type.\\n    /// @return clock_ The `Clock` containing the `_duration` and `_timestamp`.\\n    function wrap(Duration _duration, Timestamp _timestamp) internal pure returns (Clock clock_) {\\n        assembly {\\n            clock_ := or(shl(0x40, _duration), _timestamp)\\n        }\\n    }\\n\\n    /// @notice Pull the `Duration` out of a `Clock` type.\\n    /// @param _clock The `Clock` type to pull the `Duration` out of.\\n    /// @return duration_ The `Duration` pulled out of `_clock`.\\n    function duration(Clock _clock) internal pure returns (Duration duration_) {\\n        // Shift the high-order 64 bits into the low-order 64 bits, leaving only the `duration`.\\n        assembly {\\n            duration_ := shr(0x40, _clock)\\n        }\\n    }\\n\\n    /// @notice Pull the `Timestamp` out of a `Clock` type.\\n    /// @param _clock The `Clock` type to pull the `Timestamp` out of.\\n    /// @return timestamp_ The `Timestamp` pulled out of `_clock`.\\n    function timestamp(Clock _clock) internal pure returns (Timestamp timestamp_) {\\n        // Clean the high-order 192 bits by shifting the clock left and then right again, leaving\\n        // only the `timestamp`.\\n        assembly {\\n            timestamp_ := shr(0xC0, shl(0xC0, _clock))\\n        }\\n    }\\n\\n    /// @notice Get the value of a `Clock` type in the form of the underlying uint128.\\n    /// @param _clock The `Clock` type to get the value of.\\n    /// @return clock_ The value of the `Clock` type as a uint128 type.\\n    function raw(Clock _clock) internal pure returns (uint128 clock_) {\\n        assembly {\\n            clock_ := _clock\\n        }\\n    }\\n}\\n\\n/// @notice A `GameId` represents a packed 4 byte game ID, a 8 byte timestamp, and a 20 byte address.\\n/// @dev The packed layout of this type is as follows:\\n/// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n/// \u2502   Bits    \u2502   Value   \u2502\\n/// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n/// \u2502 [0, 32)   \u2502 Game Type \u2502\\n/// \u2502 [32, 96)  \u2502 Timestamp \u2502\\n/// \u2502 [96, 256) \u2502 Address   \u2502\\n/// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\ntype GameId is bytes32;\\n\\n/// @title LibGameId\\n/// @notice Utility functions for packing and unpacking GameIds.\\nlibrary LibGameId {\\n    /// @notice Packs values into a 32 byte GameId type.\\n    /// @param _gameType The game type.\\n    /// @param _timestamp The timestamp of the game's creation.\\n    /// @param _gameProxy The game proxy address.\\n    /// @return gameId_ The packed GameId.\\n    function pack(\\n        GameType _gameType,\\n        Timestamp _timestamp,\\n        address _gameProxy\\n    )\\n        internal\\n        pure\\n        returns (GameId gameId_)\\n    {\\n        assembly {\\n            gameId_ := or(or(shl(224, _gameType), shl(160, _timestamp)), _gameProxy)\\n        }\\n    }\\n\\n    /// @notice Unpacks values from a 32 byte GameId type.\\n    /// @param _gameId The packed GameId.\\n    /// @return gameType_ The game type.\\n    /// @return timestamp_ The timestamp of the game's creation.\\n    /// @return gameProxy_ The game proxy address.\\n    function unpack(GameId _gameId)\\n        internal\\n        pure\\n        returns (GameType gameType_, Timestamp timestamp_, address gameProxy_)\\n    {\\n        assembly {\\n            gameType_ := shr(224, _gameId)\\n            timestamp_ := and(shr(160, _gameId), 0xFFFFFFFFFFFFFFFF)\\n            gameProxy_ := and(_gameId, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        }\\n    }\\n}\\n\\n/// @notice A claim represents an MPT root representing the state of the fault proof program.\\ntype Claim is bytes32;\\n\\n/// @title LibClaim\\n/// @notice This library contains helper functions for working with the `Claim` type.\\nlibrary LibClaim {\\n    /// @notice Get the value of a `Claim` type in the form of the underlying bytes32.\\n    /// @param _claim The `Claim` type to get the value of.\\n    /// @return claim_ The value of the `Claim` type as a bytes32 type.\\n    function raw(Claim _claim) internal pure returns (bytes32 claim_) {\\n        assembly {\\n            claim_ := _claim\\n        }\\n    }\\n\\n    /// @notice Hashes a claim and a position together.\\n    /// @param _claim A Claim type.\\n    /// @param _position The position of `claim`.\\n    /// @param _challengeIndex The index of the claim being moved against.\\n    /// @return claimHash_ A hash of abi.encodePacked(claim, position|challengeIndex);\\n    function hashClaimPos(\\n        Claim _claim,\\n        Position _position,\\n        uint256 _challengeIndex\\n    )\\n        internal\\n        pure\\n        returns (Hash claimHash_)\\n    {\\n        assembly {\\n            mstore(0x00, _claim)\\n            mstore(0x20, or(shl(128, _position), and(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, _challengeIndex)))\\n            claimHash_ := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\\n/// @notice A dedicated duration type.\\n/// @dev Unit: seconds\\ntype Duration is uint64;\\n\\n/// @title LibDuration\\n/// @notice This library contains helper functions for working with the `Duration` type.\\nlibrary LibDuration {\\n    /// @notice Get the value of a `Duration` type in the form of the underlying uint64.\\n    /// @param _duration The `Duration` type to get the value of.\\n    /// @return duration_ The value of the `Duration` type as a uint64 type.\\n    function raw(Duration _duration) internal pure returns (uint64 duration_) {\\n        assembly {\\n            duration_ := _duration\\n        }\\n    }\\n}\\n\\n/// @notice A custom type for a generic hash.\\ntype Hash is bytes32;\\n\\n/// @title LibHash\\n/// @notice This library contains helper functions for working with the `Hash` type.\\nlibrary LibHash {\\n    /// @notice Get the value of a `Hash` type in the form of the underlying bytes32.\\n    /// @param _hash The `Hash` type to get the value of.\\n    /// @return hash_ The value of the `Hash` type as a bytes32 type.\\n    function raw(Hash _hash) internal pure returns (bytes32 hash_) {\\n        assembly {\\n            hash_ := _hash\\n        }\\n    }\\n}\\n\\n/// @notice A dedicated timestamp type.\\ntype Timestamp is uint64;\\n\\n/// @title LibTimestamp\\n/// @notice This library contains helper functions for working with the `Timestamp` type.\\nlibrary LibTimestamp {\\n    /// @notice Get the value of a `Timestamp` type in the form of the underlying uint64.\\n    /// @param _timestamp The `Timestamp` type to get the value of.\\n    /// @return timestamp_ The value of the `Timestamp` type as a uint64 type.\\n    function raw(Timestamp _timestamp) internal pure returns (uint64 timestamp_) {\\n        assembly {\\n            timestamp_ := _timestamp\\n        }\\n    }\\n}\\n\\n/// @notice A `VMStatus` represents the status of a VM execution.\\ntype VMStatus is uint8;\\n\\n/// @title LibVMStatus\\n/// @notice This library contains helper functions for working with the `VMStatus` type.\\nlibrary LibVMStatus {\\n    /// @notice Get the value of a `VMStatus` type in the form of the underlying uint8.\\n    /// @param _vmstatus The `VMStatus` type to get the value of.\\n    /// @return vmstatus_ The value of the `VMStatus` type as a uint8 type.\\n    function raw(VMStatus _vmstatus) internal pure returns (uint8 vmstatus_) {\\n        assembly {\\n            vmstatus_ := _vmstatus\\n        }\\n    }\\n}\\n\\n/// @notice A `GameType` represents the type of game being played.\\ntype GameType is uint32;\\n\\n/// @title LibGameType\\n/// @notice This library contains helper functions for working with the `GameType` type.\\nlibrary LibGameType {\\n    /// @notice Get the value of a `GameType` type in the form of the underlying uint32.\\n    /// @param _gametype The `GameType` type to get the value of.\\n    /// @return gametype_ The value of the `GameType` type as a uint32 type.\\n    function raw(GameType _gametype) internal pure returns (uint32 gametype_) {\\n        assembly {\\n            gametype_ := _gametype\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/dispute/lib/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\n// Libraries\\nimport {\\n    Position,\\n    Hash,\\n    GameType,\\n    VMStatus,\\n    Timestamp,\\n    Duration,\\n    Clock,\\n    GameId,\\n    Claim,\\n    LibGameId,\\n    LibClock\\n} from \\\"src/dispute/lib/LibUDT.sol\\\";\\n\\n/// @notice The current status of the dispute game.\\nenum GameStatus {\\n    // The game is currently in progress, and has not been resolved.\\n    IN_PROGRESS,\\n    // The game has concluded, and the `rootClaim` was challenged successfully.\\n    CHALLENGER_WINS,\\n    // The game has concluded, and the `rootClaim` could not be contested.\\n    DEFENDER_WINS\\n}\\n\\n/// @notice The game's bond distribution type. Games are expected to start in the `UNDECIDED`\\n///         state, and then choose either `NORMAL` or `REFUND`.\\nenum BondDistributionMode {\\n    // Bond distribution strategy has not been chosen.\\n    UNDECIDED,\\n    // Bonds should be distributed as normal.\\n    NORMAL,\\n    // Bonds should be refunded to claimants.\\n    REFUND\\n}\\n\\n/// @notice Represents an L2 root and the L2 sequence number at which it was generated.\\n/// @custom:field root The output root.\\n/// @custom:field l2SequenceNumber The L2 Sequence Number ( e.g. block number / timestamp) at which the root was\\n/// generated.\\nstruct Proposal {\\n    Hash root;\\n    uint256 l2SequenceNumber;\\n}\\n\\n/// @title GameTypes\\n/// @notice A library that defines the IDs of games that can be played.\\nlibrary GameTypes {\\n    /// @dev A dispute game type the uses the cannon vm.\\n    GameType internal constant CANNON = GameType.wrap(0);\\n\\n    /// @dev A permissioned dispute game type that uses the cannon vm.\\n    GameType internal constant PERMISSIONED_CANNON = GameType.wrap(1);\\n\\n    /// @notice A dispute game type that uses the asterisc vm.\\n    GameType internal constant ASTERISC = GameType.wrap(2);\\n\\n    /// @notice A dispute game type that uses the asterisc vm with Kona.\\n    GameType internal constant ASTERISC_KONA = GameType.wrap(3);\\n\\n    /// @notice A dispute game type that uses the cannon vm (Super Roots).\\n    GameType internal constant SUPER_CANNON = GameType.wrap(4);\\n\\n    /// @notice A dispute game type that uses the permissioned cannon vm (Super Roots).\\n    GameType internal constant SUPER_PERMISSIONED_CANNON = GameType.wrap(5);\\n\\n    /// @notice A dispute game type that uses OP Succinct\\n    GameType internal constant OP_SUCCINCT = GameType.wrap(6);\\n\\n    /// @notice A dispute game type with short game duration for testing withdrawals.\\n    ///         Not intended for production use.\\n    GameType internal constant FAST = GameType.wrap(254);\\n\\n    /// @notice A dispute game type that uses an alphabet vm.\\n    ///         Not intended for production use.\\n    GameType internal constant ALPHABET = GameType.wrap(255);\\n\\n    /// @notice A dispute game type that uses RISC Zero's Kailua\\n    GameType internal constant KAILUA = GameType.wrap(1337);\\n}\\n\\n/// @title VMStatuses\\n/// @notice Named type aliases for the various valid VM status bytes.\\nlibrary VMStatuses {\\n    /// @notice The VM has executed successfully and the outcome is valid.\\n    VMStatus internal constant VALID = VMStatus.wrap(0);\\n\\n    /// @notice The VM has executed successfully and the outcome is invalid.\\n    VMStatus internal constant INVALID = VMStatus.wrap(1);\\n\\n    /// @notice The VM has paniced.\\n    VMStatus internal constant PANIC = VMStatus.wrap(2);\\n\\n    /// @notice The VM execution is still in progress.\\n    VMStatus internal constant UNFINISHED = VMStatus.wrap(3);\\n}\\n\\n/// @title LocalPreimageKey\\n/// @notice Named type aliases for local `PreimageOracle` key identifiers.\\nlibrary LocalPreimageKey {\\n    /// @notice The identifier for the L1 head hash.\\n    uint256 internal constant L1_HEAD_HASH = 0x01;\\n\\n    /// @notice The identifier for the starting output root.\\n    uint256 internal constant STARTING_OUTPUT_ROOT = 0x02;\\n\\n    /// @notice The identifier for the disputed output root.\\n    uint256 internal constant DISPUTED_OUTPUT_ROOT = 0x03;\\n\\n    /// @notice The identifier for the disputed L2 block number.\\n    uint256 internal constant DISPUTED_L2_BLOCK_NUMBER = 0x04;\\n\\n    /// @notice The identifier for the chain ID.\\n    uint256 internal constant CHAIN_ID = 0x05;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Interfaces\\nimport { IResourceMetering } from \\\"interfaces/L1/IResourceMetering.sol\\\";\\n\\n/// @title Constants\\n/// @notice Constants is a library for storing constants. Simple! Don't put everything in here, just\\n///         the stuff used in multiple contracts. Constants that only apply to a single contract\\n///         should be defined in that contract instead.\\nlibrary Constants {\\n    /// @notice Special address to be used as the tx origin for gas estimation calls in the\\n    ///         OptimismPortal and CrossDomainMessenger calls. You only need to use this address if\\n    ///         the minimum gas limit specified by the user is not actually enough to execute the\\n    ///         given message and you're attempting to estimate the actual necessary gas limit. We\\n    ///         use address(1) because it's the ecrecover precompile and therefore guaranteed to\\n    ///         never have any code on any EVM chain.\\n    address internal constant ESTIMATION_ADDRESS = address(1);\\n\\n    /// @notice Value used for the L2 sender storage slot in both the OptimismPortal and the\\n    ///         CrossDomainMessenger contracts before an actual sender is set. This value is\\n    ///         non-zero to reduce the gas cost of message passing transactions.\\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\\n\\n    /// @notice The storage slot that holds the address of a proxy implementation.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\\n    bytes32 internal constant PROXY_IMPLEMENTATION_ADDRESS =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice The storage slot that holds the address of the owner.\\n    /// @dev `bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)`\\n    bytes32 internal constant PROXY_OWNER_ADDRESS = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice The address that represents ether when dealing with ERC20 token addresses.\\n    address internal constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice The address that represents the system caller responsible for L1 attributes\\n    ///         transactions.\\n    address internal constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\\n\\n    /// @notice Returns the default values for the ResourceConfig. These are the recommended values\\n    ///         for a production network.\\n    function DEFAULT_RESOURCE_CONFIG() internal pure returns (IResourceMetering.ResourceConfig memory) {\\n        IResourceMetering.ResourceConfig memory config = IResourceMetering.ResourceConfig({\\n            maxResourceLimit: 20_000_000,\\n            elasticityMultiplier: 10,\\n            baseFeeMaxChangeDenominator: 8,\\n            minimumBaseFee: 1 gwei,\\n            systemTxMaxGas: 1_000_000,\\n            maximumBaseFee: type(uint128).max\\n        });\\n        return config;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Encoding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Hashing } from \\\"src/libraries/Hashing.sol\\\";\\nimport { RLPWriter } from \\\"src/libraries/rlp/RLPWriter.sol\\\";\\n\\n/// @title Encoding\\n/// @notice Encoding handles Optimism's various different encoding schemes.\\nlibrary Encoding {\\n    /// @notice Thrown when a provided Super Root proof has an invalid version.\\n    error Encoding_InvalidSuperRootVersion();\\n\\n    /// @notice Thrown when a provided Super Root proof has no Output Roots.\\n    error Encoding_EmptySuperRoot();\\n\\n    /// @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\\n    ///         to the L2 system. Useful for searching for a deposit in the L2 system. The\\n    ///         transaction is prefixed with 0x7e to identify its EIP-2718 type.\\n    /// @param _tx User deposit transaction to encode.\\n    /// @return RLP encoded L2 deposit transaction.\\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes memory) {\\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\\n        bytes[] memory raw = new bytes[](8);\\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\\n        raw[1] = RLPWriter.writeAddress(_tx.from);\\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\\\"\\\") : RLPWriter.writeAddress(_tx.to);\\n        raw[3] = RLPWriter.writeUint(_tx.mint);\\n        raw[4] = RLPWriter.writeUint(_tx.value);\\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\\n        raw[6] = RLPWriter.writeBool(false);\\n        raw[7] = RLPWriter.writeBytes(_tx.data);\\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\\n    }\\n\\n    /// @notice Encodes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        (, uint16 version) = decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Encoding: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // nosemgrep: sol-style-use-abi-encodecall\\n        return abi.encodeWithSignature(\\\"relayMessage(address,address,bytes,uint256)\\\", _target, _sender, _data, _nonce);\\n    }\\n\\n    /// @notice Encodes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Encoded cross domain message.\\n    function encodeCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // nosemgrep: sol-style-use-abi-encodecall\\n        return abi.encodeWithSignature(\\n            \\\"relayMessage(uint256,address,address,uint256,uint256,bytes)\\\",\\n            _nonce,\\n            _sender,\\n            _target,\\n            _value,\\n            _gasLimit,\\n            _data\\n        );\\n    }\\n\\n    /// @notice Adds a version number into the first two bytes of a message nonce.\\n    /// @param _nonce   Message nonce to encode into.\\n    /// @param _version Version number to encode into the message nonce.\\n    /// @return Message nonce with version encoded into the first two bytes.\\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\\n        uint256 nonce;\\n        assembly {\\n            nonce := or(shl(240, _version), _nonce)\\n        }\\n        return nonce;\\n    }\\n\\n    /// @notice Pulls the version out of a version-encoded nonce.\\n    /// @param _nonce Message nonce with version encoded into the first two bytes.\\n    /// @return Nonce without encoded version.\\n    /// @return Version of the message.\\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\\n        uint240 nonce;\\n        uint16 version;\\n        assembly {\\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            version := shr(240, _nonce)\\n        }\\n        return (nonce, version);\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesEcotone\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    function encodeSetL1BlockValuesEcotone(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesEcotone()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash\\n        );\\n    }\\n\\n    /// @notice Returns an appropriately encoded call to L1Block.setL1BlockValuesIsthmus\\n    /// @param _baseFeeScalar       L1 base fee Scalar\\n    /// @param _blobBaseFeeScalar   L1 blob base fee Scalar\\n    /// @param _sequenceNumber      Number of L2 blocks since epoch start.\\n    /// @param _timestamp           L1 timestamp.\\n    /// @param _number              L1 blocknumber.\\n    /// @param _baseFee             L1 base fee.\\n    /// @param _blobBaseFee         L1 blob base fee.\\n    /// @param _hash                L1 blockhash.\\n    /// @param _batcherHash         Versioned hash to authenticate batcher by.\\n    /// @param _operatorFeeScalar   Operator fee scalar.\\n    /// @param _operatorFeeConstant Operator fee constant.\\n    function encodeSetL1BlockValuesIsthmus(\\n        uint32 _baseFeeScalar,\\n        uint32 _blobBaseFeeScalar,\\n        uint64 _sequenceNumber,\\n        uint64 _timestamp,\\n        uint64 _number,\\n        uint256 _baseFee,\\n        uint256 _blobBaseFee,\\n        bytes32 _hash,\\n        bytes32 _batcherHash,\\n        uint32 _operatorFeeScalar,\\n        uint64 _operatorFeeConstant\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes4 functionSignature = bytes4(keccak256(\\\"setL1BlockValuesIsthmus()\\\"));\\n        return abi.encodePacked(\\n            functionSignature,\\n            _baseFeeScalar,\\n            _blobBaseFeeScalar,\\n            _sequenceNumber,\\n            _timestamp,\\n            _number,\\n            _baseFee,\\n            _blobBaseFee,\\n            _hash,\\n            _batcherHash,\\n            _operatorFeeScalar,\\n            _operatorFeeConstant\\n        );\\n    }\\n\\n    /// @notice Encodes a super root proof into the preimage of a Super Root.\\n    /// @param _superRootProof Super root proof to encode.\\n    /// @return Encoded super root proof.\\n    function encodeSuperRootProof(Types.SuperRootProof memory _superRootProof) internal pure returns (bytes memory) {\\n        // Version must match the expected version.\\n        if (_superRootProof.version != 0x01) {\\n            revert Encoding_InvalidSuperRootVersion();\\n        }\\n\\n        // Output roots must not be empty.\\n        if (_superRootProof.outputRoots.length == 0) {\\n            revert Encoding_EmptySuperRoot();\\n        }\\n\\n        // Start with version byte and timestamp.\\n        bytes memory encoded = bytes.concat(bytes1(_superRootProof.version), bytes8(_superRootProof.timestamp));\\n\\n        // Add each output root (chainId + root)\\n        for (uint256 i = 0; i < _superRootProof.outputRoots.length; i++) {\\n            Types.OutputRootWithChainId memory outputRoot = _superRootProof.outputRoots[i];\\n            encoded = bytes.concat(encoded, bytes32(outputRoot.chainId), outputRoot.root);\\n        }\\n\\n        return encoded;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Hashing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport { Types } from \\\"src/libraries/Types.sol\\\";\\nimport { Encoding } from \\\"src/libraries/Encoding.sol\\\";\\n\\n/// @title Hashing\\n/// @notice Hashing handles Optimism's various different hashing schemes.\\nlibrary Hashing {\\n    /// @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\\n    ///         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\\n    ///         system.\\n    /// @param _tx User deposit transaction to hash.\\n    /// @return Hash of the RLP encoded L2 deposit transaction.\\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\\n    }\\n\\n    /// @notice Computes the deposit transaction's \\\"source hash\\\", a value that guarantees the hash\\n    ///         of the L2 transaction that corresponds to a deposit is unique and is\\n    ///         deterministically generated from L1 transaction data.\\n    /// @param _l1BlockHash Hash of the L1 block where the deposit was included.\\n    /// @param _logIndex    The index of the log that created the deposit transaction.\\n    /// @return Hash of the deposit transaction's \\\"source hash\\\".\\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex) internal pure returns (bytes32) {\\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\\n        return keccak256(abi.encode(bytes32(0), depositId));\\n    }\\n\\n    /// @notice Hashes the cross domain message based on the version that is encoded into the\\n    ///         message nonce.\\n    /// @param _nonce    Message nonce with version encoded into the first two bytes.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        if (version == 0) {\\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\\n        } else if (version == 1) {\\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\\n        } else {\\n            revert(\\\"Hashing: unknown cross domain message version\\\");\\n        }\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V0 (legacy) encoding.\\n    /// @param _target Address of the target of the message.\\n    /// @param _sender Address of the sender of the message.\\n    /// @param _data   Data to send with the message.\\n    /// @param _nonce  Message nonce.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV0(\\n        address _target,\\n        address _sender,\\n        bytes memory _data,\\n        uint256 _nonce\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\\n    }\\n\\n    /// @notice Hashes a cross domain message based on the V1 (current) encoding.\\n    /// @param _nonce    Message nonce.\\n    /// @param _sender   Address of the sender of the message.\\n    /// @param _target   Address of the target of the message.\\n    /// @param _value    ETH value to send to the target.\\n    /// @param _gasLimit Gas limit to use for the message.\\n    /// @param _data     Data to send with the message.\\n    /// @return Hashed cross domain message.\\n    function hashCrossDomainMessageV1(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(Encoding.encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data));\\n    }\\n\\n    /// @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\\n    /// @param _tx Withdrawal transaction to hash.\\n    /// @return Hashed withdrawal transaction.\\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data));\\n    }\\n\\n    /// @notice Hashes the various elements of an output root proof into an output root hash which\\n    ///         can be used to check if the proof is valid.\\n    /// @param _outputRootProof Output root proof which should hash to an output root.\\n    /// @return Hashed output root proof.\\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _outputRootProof.version,\\n                _outputRootProof.stateRoot,\\n                _outputRootProof.messagePasserStorageRoot,\\n                _outputRootProof.latestBlockhash\\n            )\\n        );\\n    }\\n\\n    /// @notice Generates a unique hash for cross l2 messages. This hash is used to identify\\n    ///         the message and ensure it is not relayed more than once.\\n    /// @param _destination Chain ID of the destination chain.\\n    /// @param _source Chain ID of the source chain.\\n    /// @param _nonce Unique nonce associated with the message to prevent replay attacks.\\n    /// @param _sender Address of the user who originally sent the message.\\n    /// @param _target Address of the contract or wallet that the message is targeting on the destination chain.\\n    /// @param _message The message payload to be relayed to the target on the destination chain.\\n    /// @return Hash of the encoded message parameters, used to uniquely identify the message.\\n    function hashL2toL2CrossDomainMessage(\\n        uint256 _destination,\\n        uint256 _source,\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        bytes memory _message\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(_destination, _source, _nonce, _sender, _target, _message));\\n    }\\n\\n    /// @notice Hashes a Super Root proof into a Super Root.\\n    /// @param _superRootProof Super Root proof to hash.\\n    /// @return Hashed super root proof.\\n    function hashSuperRootProof(Types.SuperRootProof memory _superRootProof) internal pure returns (bytes32) {\\n        return keccak256(Encoding.encodeSuperRootProof(_superRootProof));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Predeploys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Predeploys\\n/// @notice Contains constant addresses for protocol contracts that are pre-deployed to the L2 system.\\n//          This excludes the preinstalls (non-protocol contracts).\\nlibrary Predeploys {\\n    /// @notice Number of predeploy-namespace addresses reserved for protocol usage.\\n    uint256 internal constant PREDEPLOY_COUNT = 2048;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyMessagePasser predeploy. Deprecate. Use the updated\\n    ///         L2ToL1MessagePasser contract instead.\\n    address internal constant LEGACY_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\\n    ///         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\\n    ///         Not embedded into new OP-Stack chains.\\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the DeployerWhitelist predeploy. No longer active.\\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\\n\\n    /// @notice Address of the canonical WETH contract.\\n    address internal constant WETH = 0x4200000000000000000000000000000000000006;\\n\\n    /// @notice Address of the L2CrossDomainMessenger predeploy.\\n    address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\\n\\n    /// @notice Address of the GasPriceOracle predeploy. Includes fee information\\n    ///         and helpers for computing the L1 portion of the transaction fee.\\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\\n\\n    /// @notice Address of the L2StandardBridge predeploy.\\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\\n\\n    //// @notice Address of the SequencerFeeWallet predeploy.\\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\\n\\n    /// @notice Address of the OptimismMintableERC20Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY = 0x4200000000000000000000000000000000000012;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\\n    ///         instead, which exposes more information about the L1 state.\\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\\n\\n    /// @notice Address of the L2ERC721Bridge predeploy.\\n    address internal constant L2_ERC721_BRIDGE = 0x4200000000000000000000000000000000000014;\\n\\n    /// @notice Address of the L1Block predeploy.\\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\\n\\n    /// @notice Address of the L2ToL1MessagePasser predeploy.\\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000016;\\n\\n    /// @notice Address of the OptimismMintableERC721Factory predeploy.\\n    address internal constant OPTIMISM_MINTABLE_ERC721_FACTORY = 0x4200000000000000000000000000000000000017;\\n\\n    /// @notice Address of the ProxyAdmin predeploy.\\n    address internal constant PROXY_ADMIN = 0x4200000000000000000000000000000000000018;\\n\\n    /// @notice Address of the BaseFeeVault predeploy.\\n    address internal constant BASE_FEE_VAULT = 0x4200000000000000000000000000000000000019;\\n\\n    /// @notice Address of the L1FeeVault predeploy.\\n    address internal constant L1_FEE_VAULT = 0x420000000000000000000000000000000000001A;\\n\\n    /// @notice Address of the OperatorFeeVault predeploy.\\n    address internal constant OPERATOR_FEE_VAULT = 0x420000000000000000000000000000000000001b;\\n\\n    /// @notice Address of the SchemaRegistry predeploy.\\n    address internal constant SCHEMA_REGISTRY = 0x4200000000000000000000000000000000000020;\\n\\n    /// @notice Address of the EAS predeploy.\\n    address internal constant EAS = 0x4200000000000000000000000000000000000021;\\n\\n    /// @notice Address of the GovernanceToken predeploy.\\n    address internal constant GOVERNANCE_TOKEN = 0x4200000000000000000000000000000000000042;\\n\\n    /// @custom:legacy\\n    /// @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\\n    ///         state trie as of the Bedrock upgrade. Contract has been locked and write functions\\n    ///         can no longer be accessed.\\n    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\\n\\n    /// @notice Address of the CrossL2Inbox predeploy.\\n    address internal constant CROSS_L2_INBOX = 0x4200000000000000000000000000000000000022;\\n\\n    /// @notice Address of the L2ToL2CrossDomainMessenger predeploy.\\n    address internal constant L2_TO_L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000023;\\n\\n    /// @notice Address of the SuperchainETHBridge predeploy.\\n    address internal constant SUPERCHAIN_ETH_BRIDGE = 0x4200000000000000000000000000000000000024;\\n\\n    /// @notice Address of the ETHLiquidity predeploy.\\n    address internal constant ETH_LIQUIDITY = 0x4200000000000000000000000000000000000025;\\n\\n    /// @notice Address of the OptimismSuperchainERC20Factory predeploy.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20_FACTORY = 0x4200000000000000000000000000000000000026;\\n\\n    /// @notice Address of the OptimismSuperchainERC20Beacon predeploy.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20_BEACON = 0x4200000000000000000000000000000000000027;\\n\\n    // TODO: Precalculate the address of the implementation contract\\n    /// @notice Arbitrary address of the OptimismSuperchainERC20 implementation contract.\\n    address internal constant OPTIMISM_SUPERCHAIN_ERC20 = 0xB9415c6cA93bdC545D4c5177512FCC22EFa38F28;\\n\\n    /// @notice Address of the SuperchainTokenBridge predeploy.\\n    address internal constant SUPERCHAIN_TOKEN_BRIDGE = 0x4200000000000000000000000000000000000028;\\n\\n    /// @notice Returns the name of the predeploy at the given address.\\n    function getName(address _addr) internal pure returns (string memory out_) {\\n        require(isPredeployNamespace(_addr), \\\"Predeploys: address must be a predeploy\\\");\\n        if (_addr == LEGACY_MESSAGE_PASSER) return \\\"LegacyMessagePasser\\\";\\n        if (_addr == L1_MESSAGE_SENDER) return \\\"L1MessageSender\\\";\\n        if (_addr == DEPLOYER_WHITELIST) return \\\"DeployerWhitelist\\\";\\n        if (_addr == WETH) return \\\"WETH\\\";\\n        if (_addr == L2_CROSS_DOMAIN_MESSENGER) return \\\"L2CrossDomainMessenger\\\";\\n        if (_addr == GAS_PRICE_ORACLE) return \\\"GasPriceOracle\\\";\\n        if (_addr == L2_STANDARD_BRIDGE) return \\\"L2StandardBridge\\\";\\n        if (_addr == SEQUENCER_FEE_WALLET) return \\\"SequencerFeeVault\\\";\\n        if (_addr == OPTIMISM_MINTABLE_ERC20_FACTORY) return \\\"OptimismMintableERC20Factory\\\";\\n        if (_addr == L1_BLOCK_NUMBER) return \\\"L1BlockNumber\\\";\\n        if (_addr == L2_ERC721_BRIDGE) return \\\"L2ERC721Bridge\\\";\\n        if (_addr == L1_BLOCK_ATTRIBUTES) return \\\"L1Block\\\";\\n        if (_addr == L2_TO_L1_MESSAGE_PASSER) return \\\"L2ToL1MessagePasser\\\";\\n        if (_addr == OPTIMISM_MINTABLE_ERC721_FACTORY) return \\\"OptimismMintableERC721Factory\\\";\\n        if (_addr == PROXY_ADMIN) return \\\"ProxyAdmin\\\";\\n        if (_addr == BASE_FEE_VAULT) return \\\"BaseFeeVault\\\";\\n        if (_addr == L1_FEE_VAULT) return \\\"L1FeeVault\\\";\\n        if (_addr == OPERATOR_FEE_VAULT) return \\\"OperatorFeeVault\\\";\\n        if (_addr == SCHEMA_REGISTRY) return \\\"SchemaRegistry\\\";\\n        if (_addr == EAS) return \\\"EAS\\\";\\n        if (_addr == GOVERNANCE_TOKEN) return \\\"GovernanceToken\\\";\\n        if (_addr == LEGACY_ERC20_ETH) return \\\"LegacyERC20ETH\\\";\\n        if (_addr == CROSS_L2_INBOX) return \\\"CrossL2Inbox\\\";\\n        if (_addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER) return \\\"L2ToL2CrossDomainMessenger\\\";\\n        if (_addr == SUPERCHAIN_ETH_BRIDGE) return \\\"SuperchainETHBridge\\\";\\n        if (_addr == ETH_LIQUIDITY) return \\\"ETHLiquidity\\\";\\n        if (_addr == OPTIMISM_SUPERCHAIN_ERC20_FACTORY) return \\\"OptimismSuperchainERC20Factory\\\";\\n        if (_addr == OPTIMISM_SUPERCHAIN_ERC20_BEACON) return \\\"OptimismSuperchainERC20Beacon\\\";\\n        if (_addr == SUPERCHAIN_TOKEN_BRIDGE) return \\\"SuperchainTokenBridge\\\";\\n        revert(\\\"Predeploys: unnamed predeploy\\\");\\n    }\\n\\n    /// @notice Returns true if the predeploy is not proxied.\\n    function notProxied(address _addr) internal pure returns (bool) {\\n        return _addr == GOVERNANCE_TOKEN || _addr == WETH;\\n    }\\n\\n    /// @notice Returns true if the address is a defined predeploy that is embedded into new OP-Stack chains.\\n    function isSupportedPredeploy(address _addr, bool _useInterop) internal pure returns (bool) {\\n        return _addr == LEGACY_MESSAGE_PASSER || _addr == DEPLOYER_WHITELIST || _addr == WETH\\n            || _addr == L2_CROSS_DOMAIN_MESSENGER || _addr == GAS_PRICE_ORACLE || _addr == L2_STANDARD_BRIDGE\\n            || _addr == SEQUENCER_FEE_WALLET || _addr == OPTIMISM_MINTABLE_ERC20_FACTORY || _addr == L1_BLOCK_NUMBER\\n            || _addr == L2_ERC721_BRIDGE || _addr == L1_BLOCK_ATTRIBUTES || _addr == L2_TO_L1_MESSAGE_PASSER\\n            || _addr == OPTIMISM_MINTABLE_ERC721_FACTORY || _addr == PROXY_ADMIN || _addr == BASE_FEE_VAULT\\n            || _addr == L1_FEE_VAULT || _addr == OPERATOR_FEE_VAULT || _addr == SCHEMA_REGISTRY || _addr == EAS\\n            || _addr == GOVERNANCE_TOKEN || (_useInterop && _addr == CROSS_L2_INBOX)\\n            || (_useInterop && _addr == L2_TO_L2_CROSS_DOMAIN_MESSENGER);\\n    }\\n\\n    function isPredeployNamespace(address _addr) internal pure returns (bool) {\\n        return uint160(_addr) >> 11 == uint160(0x4200000000000000000000000000000000000000) >> 11;\\n    }\\n\\n    /// @notice Function to compute the expected address of the predeploy implementation\\n    ///         in the genesis state.\\n    function predeployToCodeNamespace(address _addr) internal pure returns (address) {\\n        require(\\n            isPredeployNamespace(_addr), \\\"Predeploys: can only derive code-namespace address for predeploy addresses\\\"\\n        );\\n        return address(\\n            uint160(uint256(uint160(_addr)) & 0xffff | uint256(uint160(0xc0D3C0d3C0d3C0D3c0d3C0d3c0D3C0d3c0d30000)))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SafeCall\\n/// @notice Perform low level safe calls\\nlibrary SafeCall {\\n    /// @notice Performs a low level call without copying any returndata.\\n    /// @dev Passes no calldata to the call context.\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _gas, uint256 _value) internal returns (bool success_) {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    0, // inloc\\n                    0, // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call with all gas without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    function send(address _target, uint256 _value) internal returns (bool success_) {\\n        success_ = send(_target, gasleft(), _value);\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _gas      Amount of gas to pass to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool success_)\\n    {\\n        assembly {\\n            success_ :=\\n                call(\\n                    _gas, // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0, // outloc\\n                    0 // outlen\\n                )\\n        }\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, uint256 _value, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: _value, _calldata: _calldata });\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata\\n    /// @param _target   Address to call\\n    /// @param _calldata Calldata to pass to the call\\n    function call(address _target, bytes memory _calldata) internal returns (bool success_) {\\n        success_ = call({ _target: _target, _gas: gasleft(), _value: 0, _calldata: _calldata });\\n    }\\n\\n    /// @notice Helper function to determine if there is sufficient gas remaining within the context\\n    ///         to guarantee that the minimum gas requirement for a call will be met as well as\\n    ///         optionally reserving a specified amount of gas for after the call has concluded.\\n    /// @param _minGas      The minimum amount of gas that may be passed to the target context.\\n    /// @param _reservedGas Optional amount of gas to reserve for the caller after the execution\\n    ///                     of the target context.\\n    /// @return `true` if there is enough gas remaining to safely supply `_minGas` to the target\\n    ///         context as well as reserve `_reservedGas` for the caller after the execution of\\n    ///         the target context.\\n    /// @dev !!!!! FOOTGUN ALERT !!!!!\\n    ///      1.) The 40_000 base buffer is to account for the worst case of the dynamic cost of the\\n    ///          `CALL` opcode's `address_access_cost`, `positive_value_cost`, and\\n    ///          `value_to_empty_account_cost` factors with an added buffer of 5,700 gas. It is\\n    ///          still possible to self-rekt by initiating a withdrawal with a minimum gas limit\\n    ///          that does not account for the `memory_expansion_cost` & `code_execution_cost`\\n    ///          factors of the dynamic cost of the `CALL` opcode.\\n    ///      2.) This function should *directly* precede the external call if possible. There is an\\n    ///          added buffer to account for gas consumed between this check and the call, but it\\n    ///          is only 5,700 gas.\\n    ///      3.) Because EIP-150 ensures that a maximum of 63/64ths of the remaining gas in the call\\n    ///          frame may be passed to a subcontext, we need to ensure that the gas will not be\\n    ///          truncated.\\n    ///      4.) Use wisely. This function is not a silver bullet.\\n    function hasMinGas(uint256 _minGas, uint256 _reservedGas) internal view returns (bool) {\\n        bool _hasMinGas;\\n        assembly {\\n            // Equation: gas \u00d7 63 \u2265 minGas \u00d7 64 + 63(40_000 + reservedGas)\\n            _hasMinGas := iszero(lt(mul(gas(), 63), add(mul(_minGas, 64), mul(add(40000, _reservedGas), 63))))\\n        }\\n        return _hasMinGas;\\n    }\\n\\n    /// @notice Perform a low level call without copying any returndata. This function\\n    ///         will revert if the call cannot be performed with the specified minimum\\n    ///         gas.\\n    /// @param _target   Address to call\\n    /// @param _minGas   The minimum amount of gas that may be passed to the call\\n    /// @param _value    Amount of value to pass to the call\\n    /// @param _calldata Calldata to pass to the call\\n    function callWithMinGas(\\n        address _target,\\n        uint256 _minGas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (bool)\\n    {\\n        bool _success;\\n        bool _hasMinGas = hasMinGas(_minGas, 0);\\n        assembly {\\n            // Assertion: gasleft() >= (_minGas * 64) / 63 + 40_000\\n            if iszero(_hasMinGas) {\\n                // Store the \\\"Error(string)\\\" selector in scratch space.\\n                mstore(0, 0x08c379a0)\\n                // Store the pointer to the string length in scratch space.\\n                mstore(32, 32)\\n                // Store the string.\\n                //\\n                // SAFETY:\\n                // - We pad the beginning of the string with two zero bytes as well as the\\n                // length (24) to ensure that we override the free memory pointer at offset\\n                // 0x40. This is necessary because the free memory pointer is likely to\\n                // be greater than 1 byte when this function is called, but it is incredibly\\n                // unlikely that it will be greater than 3 bytes. As for the data within\\n                // 0x60, it is ensured that it is 0 due to 0x60 being the zero offset.\\n                // - It's fine to clobber the free memory pointer, we're reverting.\\n                mstore(88, 0x0000185361666543616c6c3a204e6f7420656e6f75676820676173)\\n\\n                // Revert with 'Error(\\\"SafeCall: Not enough gas\\\")'\\n                revert(28, 100)\\n            }\\n\\n            // The call will be supplied at least ((_minGas * 64) / 63) gas due to the\\n            // above assertion. This ensures that, in all circumstances (except for when the\\n            // `_minGas` does not account for the `memory_expansion_cost` and `code_execution_cost`\\n            // factors of the dynamic cost of the `CALL` opcode), the call will receive at least\\n            // the minimum amount of gas specified.\\n            _success :=\\n                call(\\n                    gas(), // gas\\n                    _target, // recipient\\n                    _value, // ether value\\n                    add(_calldata, 32), // inloc\\n                    mload(_calldata), // inlen\\n                    0x00, // outloc\\n                    0x00 // outlen\\n                )\\n        }\\n        return _success;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Storage\\n/// @notice Storage handles reading and writing to arbitary storage locations\\nlibrary Storage {\\n    /// @notice Returns an address stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function getAddress(bytes32 _slot) internal view returns (address addr_) {\\n        assembly {\\n            addr_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Stores an address in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the address in.\\n    /// @param _address The protocol version to store\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting addresses\\n    ///      in arbitrary storage slots.\\n    function setAddress(bytes32 _slot, address _address) internal {\\n        assembly {\\n            sstore(_slot, _address)\\n        }\\n    }\\n\\n    /// @notice Returns a uint256 stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function getUint(bytes32 _slot) internal view returns (uint256 value_) {\\n        assembly {\\n            value_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Stores a value in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the address in.\\n    /// @param _value The protocol version to store\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots.\\n    function setUint(bytes32 _slot, uint256 _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    /// @notice Returns a bytes32 stored in an arbitrary storage slot.\\n    ///         These storage slots decouple the storage layout from\\n    ///         solc's automation.\\n    /// @param _slot The storage slot to retrieve the address from.\\n    function getBytes32(bytes32 _slot) internal view returns (bytes32 value_) {\\n        assembly {\\n            value_ := sload(_slot)\\n        }\\n    }\\n\\n    /// @notice Stores a bytes32 value in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the address in.\\n    /// @param _value The bytes32 value to store.\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots.\\n    function setBytes32(bytes32 _slot, bytes32 _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    /// @notice Stores a bool value in an arbitrary storage slot, `_slot`.\\n    /// @param _slot The storage slot to store the bool in.\\n    /// @param _value The bool value to store\\n    /// @dev WARNING! This function must be used cautiously, as it allows for overwriting values\\n    ///      in arbitrary storage slots.\\n    function setBool(bytes32 _slot, bool _value) internal {\\n        assembly {\\n            sstore(_slot, _value)\\n        }\\n    }\\n\\n    /// @notice Returns a bool stored in an arbitrary storage slot.\\n    /// @param _slot The storage slot to retrieve the bool from.\\n    function getBool(bytes32 _slot) internal view returns (bool value_) {\\n        assembly {\\n            value_ := sload(_slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Types\\n/// @notice Contains various types used throughout the Optimism contract system.\\nlibrary Types {\\n    /// @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\\n    ///         timestamp that the output root is posted. This timestamp is used to verify that the\\n    ///         finalization period has passed since the output root was submitted.\\n    /// @custom:field outputRoot    Hash of the L2 output.\\n    /// @custom:field timestamp     Timestamp of the L1 block that the output root was submitted in.\\n    /// @custom:field l2BlockNumber L2 block number that the output corresponds to.\\n    struct OutputProposal {\\n        bytes32 outputRoot;\\n        uint128 timestamp;\\n        uint128 l2BlockNumber;\\n    }\\n\\n    /// @notice Struct representing the elements that are hashed together to generate an output root\\n    ///         which itself represents a snapshot of the L2 state.\\n    /// @custom:field version                  Version of the output root.\\n    /// @custom:field stateRoot                Root of the state trie at the block of this output.\\n    /// @custom:field messagePasserStorageRoot Root of the message passer storage trie.\\n    /// @custom:field latestBlockhash          Hash of the block this output was generated from.\\n    struct OutputRootProof {\\n        bytes32 version;\\n        bytes32 stateRoot;\\n        bytes32 messagePasserStorageRoot;\\n        bytes32 latestBlockhash;\\n    }\\n\\n    /// @notice Struct representing an output root with a chain id.\\n    /// @custom:field chainId The chain ID of the L2 chain that the output root commits to.\\n    /// @custom:field root    The output root.\\n    struct OutputRootWithChainId {\\n        uint256 chainId;\\n        bytes32 root;\\n    }\\n\\n    /// @notice Struct representing a super root proof.\\n    /// @custom:field version     The version of the super root proof.\\n    /// @custom:field timestamp   The timestamp of the super root proof.\\n    /// @custom:field outputRoots The output roots that are included in the super root proof.\\n    struct SuperRootProof {\\n        bytes1 version;\\n        uint64 timestamp;\\n        OutputRootWithChainId[] outputRoots;\\n    }\\n\\n    /// @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\\n    ///         user (as opposed to a system deposit transaction generated by the system).\\n    /// @custom:field from        Address of the sender of the transaction.\\n    /// @custom:field to          Address of the recipient of the transaction.\\n    /// @custom:field isCreation  True if the transaction is a contract creation.\\n    /// @custom:field value       Value to send to the recipient.\\n    /// @custom:field mint        Amount of ETH to mint.\\n    /// @custom:field gasLimit    Gas limit of the transaction.\\n    /// @custom:field data        Data of the transaction.\\n    /// @custom:field l1BlockHash Hash of the block the transaction was submitted in.\\n    /// @custom:field logIndex    Index of the log in the block the transaction was submitted in.\\n    struct UserDepositTransaction {\\n        address from;\\n        address to;\\n        bool isCreation;\\n        uint256 value;\\n        uint256 mint;\\n        uint64 gasLimit;\\n        bytes data;\\n        bytes32 l1BlockHash;\\n        uint256 logIndex;\\n    }\\n\\n    /// @notice Struct representing a withdrawal transaction.\\n    /// @custom:field nonce    Nonce of the withdrawal transaction\\n    /// @custom:field sender   Address of the sender of the transaction.\\n    /// @custom:field target   Address of the recipient of the transaction.\\n    /// @custom:field value    Value to send to the recipient.\\n    /// @custom:field gasLimit Gas limit of the transaction.\\n    /// @custom:field data     Data of the transaction.\\n    struct WithdrawalTransaction {\\n        uint256 nonce;\\n        address sender;\\n        address target;\\n        uint256 value;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    /// @notice Enum representing where the FeeVault withdraws funds to.\\n    /// @custom:value L1 FeeVault withdraws funds to L1.\\n    /// @custom:value L2 FeeVault withdraws funds to L2.\\n    enum WithdrawalNetwork {\\n        L1,\\n        L2\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/rlp/RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\\n/// @title RLPWriter\\n/// @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\\n///         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\\n///         modifications to improve legibility.\\nlibrary RLPWriter {\\n    /// @notice RLP encodes a byte string.\\n    /// @param _in The byte string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            out_ = _in;\\n        } else {\\n            out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n    }\\n\\n    /// @notice RLP encodes a list of RLP encoded byte byte strings.\\n    /// @param _in The list of RLP encoded byte strings.\\n    /// @return list_ The RLP encoded list of items in bytes.\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory list_) {\\n        list_ = _flatten(_in);\\n        list_ = abi.encodePacked(_writeLength(list_.length, 192), list_);\\n    }\\n\\n    /// @notice RLP encodes a string.\\n    /// @param _in The string to encode.\\n    /// @return out_ The RLP encoded string in bytes.\\n    function writeString(string memory _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(bytes(_in));\\n    }\\n\\n    /// @notice RLP encodes an address.\\n    /// @param _in The address to encode.\\n    /// @return out_ The RLP encoded address in bytes.\\n    function writeAddress(address _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /// @notice RLP encodes a uint.\\n    /// @param _in The uint256 to encode.\\n    /// @return out_ The RLP encoded uint256 in bytes.\\n    function writeUint(uint256 _in) internal pure returns (bytes memory out_) {\\n        out_ = writeBytes(_toBinary(_in));\\n    }\\n\\n    /// @notice RLP encodes a bool.\\n    /// @param _in The bool to encode.\\n    /// @return out_ The RLP encoded bool in bytes.\\n    function writeBool(bool _in) internal pure returns (bytes memory out_) {\\n        out_ = new bytes(1);\\n        out_[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n    }\\n\\n    /// @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\\n    /// @param _len    The length of the string or the payload.\\n    /// @param _offset 128 if item is string, 192 if item is list.\\n    /// @return out_ RLP encoded bytes.\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) {\\n        if (_len < 56) {\\n            out_ = new bytes(1);\\n            out_[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            out_ = new bytes(lenLen + 1);\\n            out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));\\n            }\\n        }\\n    }\\n\\n    /// @notice Encode integer in big endian binary form with no leading zeroes.\\n    /// @param _x The integer to encode.\\n    /// @return out_ RLP encoded bytes.\\n    function _toBinary(uint256 _x) private pure returns (bytes memory out_) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        out_ = new bytes(32 - i);\\n        for (uint256 j = 0; j < out_.length; j++) {\\n            out_[j] = b[i++];\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/Arachnid/solidity-stringutils\\n    /// @notice Copies a piece of memory to another location.\\n    /// @param _dest Destination location.\\n    /// @param _src  Source location.\\n    /// @param _len  Length of memory to copy.\\n    function _memcpy(uint256 _dest, uint256 _src, uint256 _len) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /// @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\\n    /// @notice Flattens a list of byte strings into one byte string.\\n    /// @param _list List of byte strings to flatten.\\n    /// @return out_ The flattened byte string.\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory out_) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        out_ = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(out_, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/universal/CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n// Libraries\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { SafeCall } from \\\"src/libraries/SafeCall.sol\\\";\\nimport { Hashing } from \\\"src/libraries/Hashing.sol\\\";\\nimport { Encoding } from \\\"src/libraries/Encoding.sol\\\";\\nimport { Constants } from \\\"src/libraries/Constants.sol\\\";\\n\\n/// @custom:legacy\\n/// @title CrossDomainMessengerLegacySpacer0\\n/// @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n///         libAddressManager variable used to exist. Must be the first contract in the inheritance\\n///         tree of the CrossDomainMessenger.\\ncontract CrossDomainMessengerLegacySpacer0 {\\n    /// @custom:legacy\\n    /// @custom:spacer libAddressManager\\n    /// @notice Spacer for backwards compatibility.\\n    address private spacer_0_0_20;\\n}\\n\\n/// @custom:legacy\\n/// @title CrossDomainMessengerLegacySpacer1\\n/// @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\\n///         PausableUpgradable and OwnableUpgradeable variables used to exist. Must be\\n///         the third contract in the inheritance tree of the CrossDomainMessenger.\\ncontract CrossDomainMessengerLegacySpacer1 {\\n    /// @custom:legacy\\n    /// @custom:spacer ContextUpgradable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         ContextUpgradable.\\n    uint256[50] private spacer_1_0_1600;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer OwnableUpgradeable's _owner\\n    /// @notice Spacer for backwards compatibility.\\n    ///         Come from OpenZeppelin OwnableUpgradeable.\\n    address private spacer_51_0_20;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer OwnableUpgradeable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         OwnableUpgradeable.\\n    uint256[49] private spacer_52_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer PausableUpgradable's _paused\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         PausableUpgradable.\\n    bool private spacer_101_0_1;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer PausableUpgradable's __gap\\n    /// @notice Spacer for backwards compatibility. Comes from OpenZeppelin\\n    ///         PausableUpgradable.\\n    uint256[49] private spacer_102_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer ReentrancyGuardUpgradeable's `_status` field.\\n    /// @notice Spacer for backwards compatibility.\\n    uint256 private spacer_151_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer ReentrancyGuardUpgradeable's __gap\\n    /// @notice Spacer for backwards compatibility.\\n    uint256[49] private spacer_152_0_1568;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer blockedMessages\\n    /// @notice Spacer for backwards compatibility.\\n    mapping(bytes32 => bool) private spacer_201_0_32;\\n\\n    /// @custom:legacy\\n    /// @custom:spacer relayedMessages\\n    /// @notice Spacer for backwards compatibility.\\n    mapping(bytes32 => bool) private spacer_202_0_32;\\n}\\n\\n/// @custom:upgradeable\\n/// @title CrossDomainMessenger\\n/// @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\\n///         cross-chain messenger contracts. It's designed to be a universal interface that only\\n///         needs to be extended slightly to provide low-level message passing functionality on each\\n///         chain it's deployed on. Currently only designed for message passing between two paired\\n///         chains and does not support one-to-many interactions.\\n///         Any changes to this contract MUST result in a semver bump for contracts that inherit it.\\nabstract contract CrossDomainMessenger is\\n    CrossDomainMessengerLegacySpacer0,\\n    Initializable,\\n    CrossDomainMessengerLegacySpacer1\\n{\\n    /// @notice Current message version identifier.\\n    uint16 public constant MESSAGE_VERSION = 1;\\n\\n    /// @notice Constant overhead added to the base gas for a message.\\n    uint64 public constant RELAY_CONSTANT_OVERHEAD = 200_000;\\n\\n    /// @notice Numerator for dynamic overhead added to the base gas for a message.\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 64;\\n\\n    /// @notice Denominator for dynamic overhead added to the base gas for a message.\\n    uint64 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 63;\\n\\n    /// @notice Extra gas added to base gas for each byte of calldata in a message.\\n    uint64 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\\n\\n    /// @notice Gas reserved for performing the external call in `relayMessage`.\\n    uint64 public constant RELAY_CALL_OVERHEAD = 40_000;\\n\\n    /// @notice Gas reserved for finalizing the execution of `relayMessage` after the safe call.\\n    uint64 public constant RELAY_RESERVED_GAS = 40_000;\\n\\n    /// @notice Gas reserved for the execution between the `hasMinGas` check and the external\\n    ///         call in `relayMessage`.\\n    uint64 public constant RELAY_GAS_CHECK_BUFFER = 5_000;\\n\\n    /// @notice Base gas required for any transaction in the EVM.\\n    uint64 public constant TX_BASE_GAS = 21_000;\\n\\n    /// @notice Floor overhead per byte of non-zero calldata in a message. Calldata floor was\\n    ///         introduced in EIP-7623.\\n    uint64 public constant FLOOR_CALLDATA_OVERHEAD = 40;\\n\\n    /// @notice Overhead added to the internal message data when the full call to relayMessage is\\n    ///         ABI encoded. This is a constant value that is specific to the V1 message encoding\\n    ///         scheme. 260 is an upper bound, actual overhead can be as low as 228 bytes for an\\n    ///         empty message.\\n    uint64 public constant ENCODING_OVERHEAD = 260;\\n\\n    /// @notice Mapping of message hashes to boolean receipt values. Note that a message will only\\n    ///         be present in this mapping if it has successfully been relayed on this chain, and\\n    ///         can therefore not be relayed again.\\n    mapping(bytes32 => bool) public successfulMessages;\\n\\n    /// @notice Address of the sender of the currently executing message on the other chain. If the\\n    ///         value of this variable is the default value (0x00000000...dead) then no message is\\n    ///         currently being executed. Use the xDomainMessageSender getter which will throw an\\n    ///         error if this is the case.\\n    address internal xDomainMsgSender;\\n\\n    /// @notice Nonce for the next message to be sent, without the message version applied. Use the\\n    ///         messageNonce getter which will insert the message version into the nonce to give you\\n    ///         the actual nonce to be used for the message.\\n    uint240 internal msgNonce;\\n\\n    /// @notice Mapping of message hashes to a boolean if and only if the message has failed to be\\n    ///         executed at least once. A message will not be present in this mapping if it\\n    ///         successfully executed on the first attempt.\\n    mapping(bytes32 => bool) public failedMessages;\\n\\n    /// @notice CrossDomainMessenger contract on the other chain.\\n    /// @custom:network-specific\\n    CrossDomainMessenger public otherMessenger;\\n\\n    /// @notice Reserve extra slots in the storage layout for future upgrades.\\n    ///         A gap size of 43 was chosen here, so that the first slot used in a child contract\\n    ///         would be 1 plus a multiple of 50.\\n    uint256[43] private __gap;\\n\\n    /// @notice Emitted whenever a message is sent to the other chain.\\n    /// @param target       Address of the recipient of the message.\\n    /// @param sender       Address of the sender of the message.\\n    /// @param message      Message to trigger the recipient address with.\\n    /// @param messageNonce Unique nonce attached to the message.\\n    /// @param gasLimit     Minimum gas limit that the message can be executed with.\\n    event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);\\n\\n    /// @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\\n    ///         SentMessage event without breaking the ABI of this contract, this is good enough.\\n    /// @param sender Address of the sender of the message.\\n    /// @param value  ETH value sent along with the message to the recipient.\\n    event SentMessageExtension1(address indexed sender, uint256 value);\\n\\n    /// @notice Emitted whenever a message is successfully relayed on this chain.\\n    /// @param msgHash Hash of the message that was relayed.\\n    event RelayedMessage(bytes32 indexed msgHash);\\n\\n    /// @notice Emitted whenever a message fails to be relayed on this chain.\\n    /// @param msgHash Hash of the message that failed to be relayed.\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /// @notice Sends a message to some target address on the other chain. Note that if the call\\n    ///         always reverts, then the message will be unrelayable, and any ETH sent will be\\n    ///         permanently locked. The same will occur if the target on the other chain is\\n    ///         considered unsafe (see the _isUnsafeTarget() function).\\n    /// @param _target      Target contract or wallet address.\\n    /// @param _message     Message to trigger the target address with.\\n    /// @param _minGasLimit Minimum gas limit that the message can be executed with.\\n    function sendMessage(address _target, bytes calldata _message, uint32 _minGasLimit) external payable {\\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\\n        // guarantee the property that the call to the target contract will always have at least\\n        // the minimum gas limit specified by the user.\\n        _sendMessage({\\n            _to: address(otherMessenger),\\n            _gasLimit: baseGas(_message, _minGasLimit),\\n            _value: msg.value,\\n            _data: abi.encodeWithSelector(\\n                this.relayMessage.selector, messageNonce(), msg.sender, _target, msg.value, _minGasLimit, _message\\n            )\\n        });\\n\\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\\n        emit SentMessageExtension1(msg.sender, msg.value);\\n\\n        unchecked {\\n            ++msgNonce;\\n        }\\n    }\\n\\n    /// @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n    ///         be executed via cross-chain call from the other messenger OR if the message was\\n    ///         already received once and is currently being replayed.\\n    /// @param _nonce       Nonce of the message being relayed.\\n    /// @param _sender      Address of the user who sent the message.\\n    /// @param _target      Address that the message is targeted at.\\n    /// @param _value       ETH value to send with the message.\\n    /// @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n    /// @param _message     Message to send to the target.\\n    function relayMessage(\\n        uint256 _nonce,\\n        address _sender,\\n        address _target,\\n        uint256 _value,\\n        uint256 _minGasLimit,\\n        bytes calldata _message\\n    )\\n        external\\n        payable\\n    {\\n        // On L1 this function will check the Portal for its paused status.\\n        // On L2 this function should be a no-op, because paused will always return false.\\n        require(paused() == false, \\\"CrossDomainMessenger: paused\\\");\\n\\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\\n        require(version < 2, \\\"CrossDomainMessenger: only version 0 or 1 messages are supported at this time\\\");\\n\\n        // If the message is version 0, then it's a migrated legacy withdrawal. We therefore need\\n        // to check that the legacy version of the message has not already been relayed.\\n        if (version == 0) {\\n            bytes32 oldHash = Hashing.hashCrossDomainMessageV0(_target, _sender, _message, _nonce);\\n            require(successfulMessages[oldHash] == false, \\\"CrossDomainMessenger: legacy withdrawal already relayed\\\");\\n        }\\n\\n        // We use the v1 message hash as the unique identifier for the message because it commits\\n        // to the value and minimum gas limit of the message.\\n        bytes32 versionedHash =\\n            Hashing.hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _minGasLimit, _message);\\n\\n        if (_isOtherMessenger()) {\\n            // These properties should always hold when the message is first submitted (as\\n            // opposed to being replayed).\\n            assert(msg.value == _value);\\n            assert(!failedMessages[versionedHash]);\\n        } else {\\n            require(msg.value == 0, \\\"CrossDomainMessenger: value must be zero unless message is from a system address\\\");\\n\\n            require(failedMessages[versionedHash], \\\"CrossDomainMessenger: message cannot be replayed\\\");\\n        }\\n\\n        require(\\n            _isUnsafeTarget(_target) == false, \\\"CrossDomainMessenger: cannot send message to blocked system address\\\"\\n        );\\n\\n        require(successfulMessages[versionedHash] == false, \\\"CrossDomainMessenger: message has already been relayed\\\");\\n\\n        // If there is not enough gas left to perform the external call and finish the execution,\\n        // return early and assign the message to the failedMessages mapping.\\n        // We are asserting that we have enough gas to:\\n        // 1. Call the target contract (_minGasLimit + RELAY_CALL_OVERHEAD + RELAY_GAS_CHECK_BUFFER)\\n        //   1.a. The RELAY_CALL_OVERHEAD is included in `hasMinGas`.\\n        // 2. Finish the execution after the external call (RELAY_RESERVED_GAS).\\n        //\\n        // If `xDomainMsgSender` is not the default L2 sender, this function\\n        // is being re-entered. This marks the message as failed to allow it to be replayed.\\n        if (\\n            !SafeCall.hasMinGas(_minGasLimit, RELAY_RESERVED_GAS + RELAY_GAS_CHECK_BUFFER)\\n                || xDomainMsgSender != Constants.DEFAULT_L2_SENDER\\n        ) {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n\\n            return;\\n        }\\n\\n        xDomainMsgSender = _sender;\\n        bool success = SafeCall.call(_target, gasleft() - RELAY_RESERVED_GAS, _value, _message);\\n        xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n\\n        if (success) {\\n            // This check is identical to one above, but it ensures that the same message cannot be relayed\\n            // twice, and adds a layer of protection against rentrancy.\\n            assert(successfulMessages[versionedHash] == false);\\n            successfulMessages[versionedHash] = true;\\n            emit RelayedMessage(versionedHash);\\n        } else {\\n            failedMessages[versionedHash] = true;\\n            emit FailedRelayedMessage(versionedHash);\\n\\n            // Revert in this case if the transaction was triggered by the estimation address. This\\n            // should only be possible during gas estimation or we have bigger problems. Reverting\\n            // here will make the behavior of gas estimation change such that the gas limit\\n            // computed will be the amount required to relay the message, even if that amount is\\n            // greater than the minimum gas limit specified by the user.\\n            if (tx.origin == Constants.ESTIMATION_ADDRESS) {\\n                revert(\\\"CrossDomainMessenger: failed to relay message\\\");\\n            }\\n        }\\n    }\\n\\n    /// @notice Retrieves the address of the contract or wallet that initiated the currently\\n    ///         executing message on the other chain. Will throw an error if there is no message\\n    ///         currently being executed. Allows the recipient of a call to see who triggered it.\\n    /// @return Address of the sender of the currently executing message on the other chain.\\n    function xDomainMessageSender() external view returns (address) {\\n        require(\\n            xDomainMsgSender != Constants.DEFAULT_L2_SENDER, \\\"CrossDomainMessenger: xDomainMessageSender is not set\\\"\\n        );\\n\\n        return xDomainMsgSender;\\n    }\\n\\n    /// @notice Retrieves the address of the paired CrossDomainMessenger contract on the other chain\\n    ///         Public getter is legacy and will be removed in the future. Use `otherMessenger()` instead.\\n    /// @return CrossDomainMessenger contract on the other chain.\\n    /// @custom:legacy\\n    function OTHER_MESSENGER() public view returns (CrossDomainMessenger) {\\n        return otherMessenger;\\n    }\\n\\n    /// @notice Retrieves the next message nonce. Message version will be added to the upper two\\n    ///         bytes of the message nonce. Message version allows us to treat messages as having\\n    ///         different structures.\\n    /// @return Nonce of the next message to be sent, with added message version.\\n    function messageNonce() public view returns (uint256) {\\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\\n    }\\n\\n    /// @notice Computes the amount of gas required to guarantee that a given message will be\\n    ///         received on the other chain without running out of gas. Guaranteeing that a message\\n    ///         will not run out of gas is important because this ensures that a message can always\\n    ///         be replayed on the other chain if it fails to execute completely.\\n    /// @param _message     Message to compute the amount of required gas for.\\n    /// @param _minGasLimit Minimum desired gas limit when message goes to target.\\n    /// @return Amount of gas required to guarantee message receipt.\\n    function baseGas(bytes memory _message, uint32 _minGasLimit) public pure returns (uint64) {\\n        // Base gas should really be computed on the fully encoded message but that would break the\\n        // expected API, so we instead just add the encoding overhead to the message length inside\\n        // of this function.\\n\\n        // We need a minimum amount of execution gas to ensure that the message will be received on\\n        // the other side without running out of gas (stored within the failedMessages mapping).\\n        // If we get beyond the hasMinGas check, then we *must* supply more than minGasLimit to\\n        // the external call.\\n        uint64 executionGas = uint64(\\n            // Constant costs for relayMessage\\n            RELAY_CONSTANT_OVERHEAD\\n            // Covers dynamic parts of the CALL opcode\\n            + RELAY_CALL_OVERHEAD\\n            // Ensures execution of relayMessage completes after call\\n            + RELAY_RESERVED_GAS\\n            // Buffer between hasMinGas check and the CALL\\n            + RELAY_GAS_CHECK_BUFFER\\n            // Minimum gas limit, multiplied by 64/63 to account for EIP-150.\\n            + ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) / MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR)\\n        );\\n\\n        // Total message size is the result of properly ABI encoding the call to relayMessage.\\n        // Since we only get the message data and not the rest of the calldata, we use the\\n        // ENCODING_OVERHEAD constant to conservatively account for the remaining bytes.\\n        uint64 totalMessageSize = uint64(_message.length + ENCODING_OVERHEAD);\\n\\n        // Finally, replicate the transaction cost formula as defined after EIP-7623. This is\\n        // mostly relevant in the L1 -> L2 case because we need to be able to cover the intrinsic\\n        // cost of the message but it doesn't hurt in the L2 -> L1 case. After EIP-7623, the cost\\n        // of a transaction is floored by its calldata size. We don't need to account for the\\n        // contract creation case because this is always a call to relayMessage.\\n        return TX_BASE_GAS\\n            + uint64(\\n                Math.max(\\n                    executionGas + (totalMessageSize * MIN_GAS_CALLDATA_OVERHEAD),\\n                    (totalMessageSize * FLOOR_CALLDATA_OVERHEAD)\\n                )\\n            );\\n    }\\n\\n    /// @notice Initializer.\\n    /// @param _otherMessenger CrossDomainMessenger contract on the other chain.\\n    function __CrossDomainMessenger_init(CrossDomainMessenger _otherMessenger) internal onlyInitializing {\\n        // We only want to set the xDomainMsgSender to the default value if it hasn't been initialized yet,\\n        // meaning that this is a fresh contract deployment.\\n        // This prevents resetting the xDomainMsgSender to the default value during an upgrade, which would enable\\n        // a reentrant withdrawal to sandwhich the upgrade replay a withdrawal twice.\\n        if (xDomainMsgSender == address(0)) {\\n            xDomainMsgSender = Constants.DEFAULT_L2_SENDER;\\n        }\\n        otherMessenger = _otherMessenger;\\n    }\\n\\n    /// @notice Sends a low-level message to the other messenger. Needs to be implemented by child\\n    ///         contracts because the logic for this depends on the network where the messenger is\\n    ///         being deployed.\\n    /// @param _to       Recipient of the message on the other chain.\\n    /// @param _gasLimit Minimum gas limit the message can be executed with.\\n    /// @param _value    Amount of ETH to send with the message.\\n    /// @param _data     Message data.\\n    function _sendMessage(address _to, uint64 _gasLimit, uint256 _value, bytes memory _data) internal virtual;\\n\\n    /// @notice Checks whether the message is coming from the other messenger. Implemented by child\\n    ///         contracts because the logic for this depends on the network where the messenger is\\n    ///         being deployed.\\n    /// @return Whether the message is coming from the other messenger.\\n    function _isOtherMessenger() internal view virtual returns (bool);\\n\\n    /// @notice Checks whether a given call target is a system address that could cause the\\n    ///         messenger to peform an unsafe action. This is NOT a mechanism for blocking user\\n    ///         addresses. This is ONLY used to prevent the execution of messages to specific\\n    ///         system addresses that could cause security issues, e.g., having the\\n    ///         CrossDomainMessenger send messages to itself.\\n    /// @param _target Address of the contract to check.\\n    /// @return Whether or not the address is an unsafe system address.\\n    function _isUnsafeTarget(address _target) internal view virtual returns (bool);\\n\\n    /// @notice This function should return true if the contract is paused.\\n    ///         On L1 this function will check the SuperchainConfig for its paused status.\\n    ///         On L2 this function should be a no-op.\\n    /// @return Whether or not the contract is paused.\\n    function paused() public view virtual returns (bool) {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/universal/ReinitializableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @title ReinitializableBase\\n/// @notice A base contract for reinitializable contracts that exposes a version number.\\nabstract contract ReinitializableBase {\\n    /// @notice Thrown when the initialization version is zero.\\n    error ReinitializableBase_ZeroInitVersion();\\n\\n    /// @notice Current initialization version.\\n    uint8 internal immutable INIT_VERSION;\\n\\n    /// @param _initVersion Current initialization version.\\n    constructor(uint8 _initVersion) {\\n        // Sanity check, we should never have a zero init version.\\n        if (_initVersion == 0) revert ReinitializableBase_ZeroInitVersion();\\n        INIT_VERSION = _initVersion;\\n    }\\n\\n    /// @notice Getter for the current initialization version.\\n    /// @return The current initialization version.\\n    function initVersion() public view returns (uint8) {\\n        return INIT_VERSION;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}"
    }
  },
  "proxy_info": {
    "is_proxy": true,
    "proxy_type": "ResolvedDelegateProxy",
    "implementation_address": "0xD26bB3aaAa4cB5638A8581A4c4b1d937D8E05c54",
    "admin_address": null,
    "additional_info": {
      "has_address_manager_param": true,
      "has_implementation_name_param": true,
      "constructor_inputs": 2,
      "function_count": 0,
      "implementation_address": "0xD26bB3aaAa4cB5638A8581A4c4b1d937D8E05c54",
      "address_manager": "0xdE1FCfB0851916CA5101820A69b13a4E276bd81F",
      "name": "OVM_L1CrossDomainMessenger",
      "resolution_method": "common_patterns"
    }
  },
  "function_analysis": {
    "function_results": {
      "ENCODING_OVERHEAD": 260,
      "FLOOR_CALLDATA_OVERHEAD": 40,
      "MESSAGE_VERSION": 1,
      "MIN_GAS_CALLDATA_OVERHEAD": 16,
      "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR": 63,
      "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR": 64,
      "OTHER_MESSENGER": "0x4200000000000000000000000000000000000007",
      "PORTAL": "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
      "RELAY_CALL_OVERHEAD": 40000,
      "RELAY_CONSTANT_OVERHEAD": 200000,
      "RELAY_GAS_CHECK_BUFFER": 5000,
      "RELAY_RESERVED_GAS": 40000,
      "TX_BASE_GAS": 21000,
      "messageNonce": 1766847064778384329583297500742918515827483896875618958121606201292660557,
      "otherMessenger": "0x4200000000000000000000000000000000000007",
      "paused": false,
      "portal": "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
      "superchainConfig": "0xE925205ad05D8d612Ac205C4941CCd61Fc965C46",
      "version": "2.6.0"
    },
    "addresses": [
      "0xE925205ad05D8d612Ac205C4941CCd61Fc965C46",
      "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
      "0x4200000000000000000000000000000000000007"
    ],
    "interesting_data": {
      "ENCODING_OVERHEAD": 260,
      "FLOOR_CALLDATA_OVERHEAD": 40,
      "MESSAGE_VERSION": 1,
      "MIN_GAS_CALLDATA_OVERHEAD": 16,
      "MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR": 63,
      "MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR": 64,
      "RELAY_CALL_OVERHEAD": 40000,
      "RELAY_CONSTANT_OVERHEAD": 200000,
      "RELAY_GAS_CHECK_BUFFER": 5000,
      "RELAY_RESERVED_GAS": 40000,
      "TX_BASE_GAS": 21000,
      "messageNonce": 1766847064778384329583297500742918515827483896875618958121606201292660557,
      "paused": false
    },
    "validator_sets": {},
    "current_epoch": null
  },
  "contract_type": "l2_bridge",
  "summary": {
    "verified": true,
    "is_proxy": true,
    "contract_type": "l2_bridge",
    "addresses_found": 3,
    "functions_called": 19,
    "validator_sets_found": 0,
    "has_specialized_analysis": false
  },
  "wrapper_context": {
    "token_name": "Lombard LBTC",
    "network": "Ethereum",
    "contract_role": "L1 Messenger",
    "analysis_purpose": "Bridge governance analysis for Lombard LBTC on Ethereum"
  },
  "associated_token_contract": "0xA45d4121b3D47719FF57a947A9d961539Ba33204"
}